// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::issuer::*;
use crate::sdk::*;
use crate::sdk_builder::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 960669938;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__sdk__BreezSdk_add_event_listener_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_add_event_listener",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_listener = <StreamSink<
                crate::events::SdkEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::sdk::BreezSdk::add_event_listener(
                                &*api_that_guard,
                                api_listener,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_cancel_leaf_optimization_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_cancel_leaf_optimization",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::cancel_leaf_optimization(&*api_that_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_check_lightning_address_available_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_check_lightning_address_available",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::CheckLightningAddressRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::check_lightning_address_available(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_check_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_check_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::CheckMessageRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::check_message(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_claim_deposit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_claim_deposit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::ClaimDepositRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::claim_deposit(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_claim_htlc_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_claim_htlc_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::ClaimHtlcPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::claim_htlc_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_delete_lightning_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_delete_lightning_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::delete_lightning_address(&*api_that_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::disconnect(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_fetch_conversion_limits_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_fetch_conversion_limits",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::FetchConversionLimitsRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::fetch_conversion_limits(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::GetInfoRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::get_info(&*api_that_guard, api_request).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_leaf_optimization_progress_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_leaf_optimization_progress",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::sdk::BreezSdk::get_leaf_optimization_progress(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_lightning_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_lightning_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::get_lightning_address(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::GetPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::get_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_token_issuer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_token_issuer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::sdk::BreezSdk::get_token_issuer(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_tokens_metadata_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_tokens_metadata",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::GetTokensMetadataRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::get_tokens_metadata(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_get_user_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_get_user_settings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::get_user_settings(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_fiat_currencies_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_fiat_currencies",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::list_fiat_currencies(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_fiat_rates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_fiat_rates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::list_fiat_rates(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::ListPaymentsRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::list_payments(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_list_unclaimed_deposits_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_list_unclaimed_deposits",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::ListUnclaimedDepositsRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::list_unclaimed_deposits(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_lnurl_auth_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_lnurl_auth",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request_data =
                <crate::models::LnurlAuthRequestDetails>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::lnurl_auth(&*api_that_guard, api_request_data)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_lnurl_pay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_lnurl_pay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::LnurlPayRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::lnurl_pay(&*api_that_guard, api_request).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_lnurl_withdraw_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_lnurl_withdraw",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::LnurlWithdrawRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::lnurl_withdraw(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_parse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_parse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_input = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::parse(&*api_that_guard, &api_input).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_prepare_lnurl_pay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_prepare_lnurl_pay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::PrepareLnurlPayRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::prepare_lnurl_pay(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_prepare_send_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_prepare_send_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::PrepareSendPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::prepare_send_payment(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_receive_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_receive_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::ReceivePaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::receive_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_recommended_fees_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_recommended_fees",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::recommended_fees(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_refund_deposit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_refund_deposit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::RefundDepositRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::refund_deposit(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_register_lightning_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_register_lightning_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::RegisterLightningAddressRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::register_lightning_address(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_remove_event_listener_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_remove_event_listener",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::sdk::BreezSdk::remove_event_listener(&*api_that_guard, &api_id)
                                .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_send_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_send_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::SendPaymentRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::send_payment(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::SignMessageRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::sign_message(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_start_leaf_optimization_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_start_leaf_optimization",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    crate::sdk::BreezSdk::start_leaf_optimization(&*api_that_guard);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__BreezSdk_sync_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_sync_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request = <crate::models::SyncWalletRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk::BreezSdk::sync_wallet(&*api_that_guard, api_request)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__BreezSdk_update_user_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BreezSdk_update_user_settings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::UpdateUserSettingsRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::sdk::BreezSdk::update_user_settings(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::sdk_builder::SdkBuilder::build(&*api_that_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_config = <crate::models::Config>::sse_decode(&mut deserializer);
            let api_seed = <crate::models::Seed>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::sdk_builder::SdkBuilder::new(api_config, api_seed))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_with_default_storage_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_with_default_storage",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <SdkBuilder>::sse_decode(&mut deserializer);
            let api_storage_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::sdk_builder::SdkBuilder::with_default_storage(api_that, api_storage_dir),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_with_key_set_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_with_key_set",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <SdkBuilder>::sse_decode(&mut deserializer);
            let api_config = <crate::models::KeySetConfig>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::sdk_builder::SdkBuilder::with_key_set(
                    api_that, api_config,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk_builder__SdkBuilder_with_rest_chain_service_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SdkBuilder_with_rest_chain_service",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <SdkBuilder>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_api_type = <crate::models::ChainApiType>::sse_decode(&mut deserializer);
            let api_credentials =
                <Option<crate::models::Credentials>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::sdk_builder::SdkBuilder::with_rest_chain_service(
                        api_that,
                        api_url,
                        api_api_type,
                        api_credentials,
                    ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__issuer__TokenIssuer_burn_issuer_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TokenIssuer_burn_issuer_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::BurnIssuerTokenRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::issuer::TokenIssuer::burn_issuer_token(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__issuer__TokenIssuer_create_issuer_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TokenIssuer_create_issuer_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::CreateIssuerTokenRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::issuer::TokenIssuer::create_issuer_token(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__issuer__TokenIssuer_freeze_issuer_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TokenIssuer_freeze_issuer_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::FreezeIssuerTokenRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::issuer::TokenIssuer::freeze_issuer_token(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__issuer__TokenIssuer_get_issuer_token_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TokenIssuer_get_issuer_token_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::issuer::TokenIssuer::get_issuer_token_balance(&*api_that_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__issuer__TokenIssuer_get_issuer_token_metadata_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TokenIssuer_get_issuer_token_metadata",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::issuer::TokenIssuer::get_issuer_token_metadata(&*api_that_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__issuer__TokenIssuer_mint_issuer_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TokenIssuer_mint_issuer_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::MintIssuerTokenRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::issuer::TokenIssuer::mint_issuer_token(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__issuer__TokenIssuer_unfreeze_issuer_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TokenIssuer_unfreeze_issuer_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::UnfreezeIssuerTokenRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::issuer::TokenIssuer::unfreeze_issuer_token(
                            &*api_that_guard,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_request = <crate::models::ConnectRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::errors::SdkError>(
                    (move || async move {
                        let output_ok = crate::sdk::connect(api_request).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__sdk__default_config_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "default_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_network = <crate::models::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::sdk::default_config(api_network))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__sdk__init_logging_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_logging",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_log_dir = <Option<String>>::sse_decode(&mut deserializer);
            let api_app_logger = <StreamSink<
                crate::logger::LogEntry,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_log_filter = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::errors::SdkError>((move || {
                let output_ok =
                    crate::sdk::init_logging(api_log_dir, api_app_logger, api_log_filter)?;
                Ok(output_ok)
            })())
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let AesSuccessActionData = None::<crate::models::AesSuccessActionData>.unwrap();
        let _: String = AesSuccessActionData.description;
        let _: String = AesSuccessActionData.ciphertext;
        let _: String = AesSuccessActionData.iv;
    }
    {
        let AesSuccessActionDataDecrypted =
            None::<crate::models::AesSuccessActionDataDecrypted>.unwrap();
        let _: String = AesSuccessActionDataDecrypted.description;
        let _: String = AesSuccessActionDataDecrypted.plaintext;
    }
    match None::<crate::models::AesSuccessActionDataResult>.unwrap() {
        crate::models::AesSuccessActionDataResult::Decrypted { data } => {
            let _: crate::models::AesSuccessActionDataDecrypted = data;
        }
        crate::models::AesSuccessActionDataResult::ErrorStatus { reason } => {
            let _: String = reason;
        }
    }
    match None::<crate::models::Amount>.unwrap() {
        crate::models::Amount::Bitcoin { amount_msat } => {
            let _: u64 = amount_msat;
        }
        crate::models::Amount::Currency {
            iso4217_code,
            fractional_amount,
        } => {
            let _: String = iso4217_code;
            let _: u64 = fractional_amount;
        }
    }
    match None::<crate::models::AssetFilter>.unwrap() {
        crate::models::AssetFilter::Bitcoin => {}
        crate::models::AssetFilter::Token { token_identifier } => {
            let _: Option<String> = token_identifier;
        }
    }
    {
        let Bip21Details = None::<crate::models::Bip21Details>.unwrap();
        let _: Option<u64> = Bip21Details.amount_sat;
        let _: Option<String> = Bip21Details.asset_id;
        let _: String = Bip21Details.uri;
        let _: Vec<crate::models::Bip21Extra> = Bip21Details.extras;
        let _: Option<String> = Bip21Details.label;
        let _: Option<String> = Bip21Details.message;
        let _: Vec<crate::models::InputType> = Bip21Details.payment_methods;
    }
    {
        let Bip21Extra = None::<crate::models::Bip21Extra>.unwrap();
        let _: String = Bip21Extra.key;
        let _: String = Bip21Extra.value;
    }
    {
        let BitcoinAddressDetails = None::<crate::models::BitcoinAddressDetails>.unwrap();
        let _: String = BitcoinAddressDetails.address;
        let _: crate::models::BitcoinNetwork = BitcoinAddressDetails.network;
        let _: crate::models::PaymentRequestSource = BitcoinAddressDetails.source;
    }
    {
        let Bolt11Invoice = None::<crate::models::Bolt11Invoice>.unwrap();
        let _: String = Bolt11Invoice.bolt11;
        let _: crate::models::PaymentRequestSource = Bolt11Invoice.source;
    }
    {
        let Bolt11InvoiceDetails = None::<crate::models::Bolt11InvoiceDetails>.unwrap();
        let _: Option<u64> = Bolt11InvoiceDetails.amount_msat;
        let _: Option<String> = Bolt11InvoiceDetails.description;
        let _: Option<String> = Bolt11InvoiceDetails.description_hash;
        let _: u64 = Bolt11InvoiceDetails.expiry;
        let _: crate::models::Bolt11Invoice = Bolt11InvoiceDetails.invoice;
        let _: u64 = Bolt11InvoiceDetails.min_final_cltv_expiry_delta;
        let _: crate::models::BitcoinNetwork = Bolt11InvoiceDetails.network;
        let _: String = Bolt11InvoiceDetails.payee_pubkey;
        let _: String = Bolt11InvoiceDetails.payment_hash;
        let _: String = Bolt11InvoiceDetails.payment_secret;
        let _: Vec<crate::models::Bolt11RouteHint> = Bolt11InvoiceDetails.routing_hints;
        let _: u64 = Bolt11InvoiceDetails.timestamp;
    }
    {
        let Bolt11RouteHint = None::<crate::models::Bolt11RouteHint>.unwrap();
        let _: Vec<crate::models::Bolt11RouteHintHop> = Bolt11RouteHint.hops;
    }
    {
        let Bolt11RouteHintHop = None::<crate::models::Bolt11RouteHintHop>.unwrap();
        let _: String = Bolt11RouteHintHop.src_node_id;
        let _: String = Bolt11RouteHintHop.short_channel_id;
        let _: u32 = Bolt11RouteHintHop.fees_base_msat;
        let _: u32 = Bolt11RouteHintHop.fees_proportional_millionths;
        let _: u16 = Bolt11RouteHintHop.cltv_expiry_delta;
        let _: Option<u64> = Bolt11RouteHintHop.htlc_minimum_msat;
        let _: Option<u64> = Bolt11RouteHintHop.htlc_maximum_msat;
    }
    {
        let Bolt12Invoice = None::<crate::models::Bolt12Invoice>.unwrap();
        let _: String = Bolt12Invoice.invoice;
        let _: crate::models::PaymentRequestSource = Bolt12Invoice.source;
    }
    {
        let Bolt12InvoiceDetails = None::<crate::models::Bolt12InvoiceDetails>.unwrap();
        let _: u64 = Bolt12InvoiceDetails.amount_msat;
        let _: crate::models::Bolt12Invoice = Bolt12InvoiceDetails.invoice;
    }
    {
        let Bolt12InvoiceRequestDetails =
            None::<crate::models::Bolt12InvoiceRequestDetails>.unwrap();
    }
    {
        let Bolt12Offer = None::<crate::models::Bolt12Offer>.unwrap();
        let _: String = Bolt12Offer.offer;
        let _: crate::models::PaymentRequestSource = Bolt12Offer.source;
    }
    {
        let Bolt12OfferBlindedPath = None::<crate::models::Bolt12OfferBlindedPath>.unwrap();
        let _: Vec<String> = Bolt12OfferBlindedPath.blinded_hops;
    }
    {
        let Bolt12OfferDetails = None::<crate::models::Bolt12OfferDetails>.unwrap();
        let _: Option<u64> = Bolt12OfferDetails.absolute_expiry;
        let _: Vec<String> = Bolt12OfferDetails.chains;
        let _: Option<String> = Bolt12OfferDetails.description;
        let _: Option<String> = Bolt12OfferDetails.issuer;
        let _: Option<crate::models::Amount> = Bolt12OfferDetails.min_amount;
        let _: crate::models::Bolt12Offer = Bolt12OfferDetails.offer;
        let _: Vec<crate::models::Bolt12OfferBlindedPath> = Bolt12OfferDetails.paths;
        let _: Option<String> = Bolt12OfferDetails.signing_pubkey;
    }
    {
        let BurnIssuerTokenRequest = None::<crate::models::BurnIssuerTokenRequest>.unwrap();
        let _: u128 = BurnIssuerTokenRequest.amount;
    }
    {
        let CheckLightningAddressRequest =
            None::<crate::models::CheckLightningAddressRequest>.unwrap();
        let _: String = CheckLightningAddressRequest.username;
    }
    {
        let CheckMessageRequest = None::<crate::models::CheckMessageRequest>.unwrap();
        let _: String = CheckMessageRequest.message;
        let _: String = CheckMessageRequest.pubkey;
        let _: String = CheckMessageRequest.signature;
    }
    {
        let CheckMessageResponse = None::<crate::models::CheckMessageResponse>.unwrap();
        let _: bool = CheckMessageResponse.is_valid;
    }
    {
        let ClaimDepositRequest = None::<crate::models::ClaimDepositRequest>.unwrap();
        let _: String = ClaimDepositRequest.txid;
        let _: u32 = ClaimDepositRequest.vout;
        let _: Option<crate::models::MaxFee> = ClaimDepositRequest.max_fee;
    }
    {
        let ClaimDepositResponse = None::<crate::models::ClaimDepositResponse>.unwrap();
        let _: crate::models::Payment = ClaimDepositResponse.payment;
    }
    {
        let ClaimHtlcPaymentRequest = None::<crate::models::ClaimHtlcPaymentRequest>.unwrap();
        let _: String = ClaimHtlcPaymentRequest.preimage;
    }
    {
        let ClaimHtlcPaymentResponse = None::<crate::models::ClaimHtlcPaymentResponse>.unwrap();
        let _: crate::models::Payment = ClaimHtlcPaymentResponse.payment;
    }
    {
        let Config = None::<crate::models::Config>.unwrap();
        let _: Option<String> = Config.api_key;
        let _: crate::models::Network = Config.network;
        let _: u32 = Config.sync_interval_secs;
        let _: Option<crate::models::MaxFee> = Config.max_deposit_claim_fee;
        let _: Option<String> = Config.lnurl_domain;
        let _: bool = Config.prefer_spark_over_lightning;
        let _: Option<Vec<crate::models::ExternalInputParser>> = Config.external_input_parsers;
        let _: bool = Config.use_default_external_input_parsers;
        let _: Option<String> = Config.real_time_sync_server_url;
        let _: bool = Config.private_enabled_default;
        let _: crate::models::OptimizationConfig = Config.optimization_config;
    }
    {
        let ConnectRequest = None::<crate::models::ConnectRequest>.unwrap();
        let _: crate::models::Config = ConnectRequest.config;
        let _: crate::models::Seed = ConnectRequest.seed;
        let _: String = ConnectRequest.storage_dir;
    }
    {
        let ConversionEstimate = None::<crate::models::ConversionEstimate>.unwrap();
        let _: crate::models::ConversionOptions = ConversionEstimate.options;
        let _: u128 = ConversionEstimate.amount;
        let _: u128 = ConversionEstimate.fee;
    }
    {
        let ConversionInfo = None::<crate::models::ConversionInfo>.unwrap();
        let _: String = ConversionInfo.pool_id;
        let _: String = ConversionInfo.conversion_id;
        let _: crate::models::ConversionStatus = ConversionInfo.status;
        let _: Option<u128> = ConversionInfo.fee;
        let _: Option<crate::models::ConversionPurpose> = ConversionInfo.purpose;
    }
    {
        let ConversionOptions = None::<crate::models::ConversionOptions>.unwrap();
        let _: crate::models::ConversionType = ConversionOptions.conversion_type;
        let _: Option<u32> = ConversionOptions.max_slippage_bps;
        let _: Option<u32> = ConversionOptions.completion_timeout_secs;
    }
    match None::<crate::models::ConversionPurpose>.unwrap() {
        crate::models::ConversionPurpose::OngoingPayment { payment_request } => {
            let _: String = payment_request;
        }
        crate::models::ConversionPurpose::SelfTransfer => {}
    }
    match None::<crate::models::ConversionType>.unwrap() {
        crate::models::ConversionType::FromBitcoin => {}
        crate::models::ConversionType::ToBitcoin {
            from_token_identifier,
        } => {
            let _: String = from_token_identifier;
        }
    }
    {
        let CreateIssuerTokenRequest = None::<crate::models::CreateIssuerTokenRequest>.unwrap();
        let _: String = CreateIssuerTokenRequest.name;
        let _: String = CreateIssuerTokenRequest.ticker;
        let _: u32 = CreateIssuerTokenRequest.decimals;
        let _: bool = CreateIssuerTokenRequest.is_freezable;
        let _: u128 = CreateIssuerTokenRequest.max_supply;
    }
    {
        let Credentials = None::<crate::models::Credentials>.unwrap();
        let _: String = Credentials.username;
        let _: String = Credentials.password;
    }
    {
        let CurrencyInfo = None::<crate::models::CurrencyInfo>.unwrap();
        let _: String = CurrencyInfo.name;
        let _: u32 = CurrencyInfo.fraction_size;
        let _: Option<u32> = CurrencyInfo.spacing;
        let _: Option<crate::models::Symbol> = CurrencyInfo.symbol;
        let _: Option<crate::models::Symbol> = CurrencyInfo.uniq_symbol;
        let _: Vec<crate::models::LocalizedName> = CurrencyInfo.localized_name;
        let _: Vec<crate::models::LocaleOverrides> = CurrencyInfo.locale_overrides;
    }
    match None::<crate::errors::DepositClaimError>.unwrap() {
        crate::errors::DepositClaimError::MaxDepositClaimFeeExceeded {
            tx,
            vout,
            max_fee,
            required_fee_sats,
            required_fee_rate_sat_per_vbyte,
        } => {
            let _: String = tx;
            let _: u32 = vout;
            let _: Option<crate::models::Fee> = max_fee;
            let _: u64 = required_fee_sats;
            let _: u64 = required_fee_rate_sat_per_vbyte;
        }
        crate::errors::DepositClaimError::MissingUtxo { tx, vout } => {
            let _: String = tx;
            let _: u32 = vout;
        }
        crate::errors::DepositClaimError::Generic { message } => {
            let _: String = message;
        }
    }
    {
        let DepositInfo = None::<crate::models::DepositInfo>.unwrap();
        let _: String = DepositInfo.txid;
        let _: u32 = DepositInfo.vout;
        let _: u64 = DepositInfo.amount_sats;
        let _: Option<String> = DepositInfo.refund_tx;
        let _: Option<String> = DepositInfo.refund_tx_id;
        let _: Option<crate::errors::DepositClaimError> = DepositInfo.claim_error;
    }
    {
        let ExternalInputParser = None::<crate::models::ExternalInputParser>.unwrap();
        let _: String = ExternalInputParser.provider_id;
        let _: String = ExternalInputParser.input_regex;
        let _: String = ExternalInputParser.parser_url;
    }
    match None::<crate::models::Fee>.unwrap() {
        crate::models::Fee::Fixed { amount } => {
            let _: u64 = amount;
        }
        crate::models::Fee::Rate { sat_per_vbyte } => {
            let _: u64 = sat_per_vbyte;
        }
    }
    {
        let FetchConversionLimitsRequest =
            None::<crate::models::FetchConversionLimitsRequest>.unwrap();
        let _: crate::models::ConversionType = FetchConversionLimitsRequest.conversion_type;
        let _: Option<String> = FetchConversionLimitsRequest.token_identifier;
    }
    {
        let FetchConversionLimitsResponse =
            None::<crate::models::FetchConversionLimitsResponse>.unwrap();
        let _: Option<u128> = FetchConversionLimitsResponse.min_from_amount;
        let _: Option<u128> = FetchConversionLimitsResponse.min_to_amount;
    }
    {
        let FiatCurrency = None::<crate::models::FiatCurrency>.unwrap();
        let _: String = FiatCurrency.id;
        let _: crate::models::CurrencyInfo = FiatCurrency.info;
    }
    {
        let FreezeIssuerTokenRequest = None::<crate::models::FreezeIssuerTokenRequest>.unwrap();
        let _: String = FreezeIssuerTokenRequest.address;
    }
    {
        let FreezeIssuerTokenResponse = None::<crate::models::FreezeIssuerTokenResponse>.unwrap();
        let _: Vec<String> = FreezeIssuerTokenResponse.impacted_output_ids;
        let _: u128 = FreezeIssuerTokenResponse.impacted_token_amount;
    }
    {
        let GetInfoRequest = None::<crate::models::GetInfoRequest>.unwrap();
        let _: Option<bool> = GetInfoRequest.ensure_synced;
    }
    {
        let GetInfoResponse = None::<crate::models::GetInfoResponse>.unwrap();
        let _: u64 = GetInfoResponse.balance_sats;
        let _: std::collections::HashMap<String, crate::models::TokenBalance> =
            GetInfoResponse.token_balances;
    }
    {
        let GetPaymentRequest = None::<crate::models::GetPaymentRequest>.unwrap();
        let _: String = GetPaymentRequest.payment_id;
    }
    {
        let GetPaymentResponse = None::<crate::models::GetPaymentResponse>.unwrap();
        let _: crate::models::Payment = GetPaymentResponse.payment;
    }
    {
        let GetTokensMetadataRequest = None::<crate::models::GetTokensMetadataRequest>.unwrap();
        let _: Vec<String> = GetTokensMetadataRequest.token_identifiers;
    }
    {
        let GetTokensMetadataResponse = None::<crate::models::GetTokensMetadataResponse>.unwrap();
        let _: Vec<crate::models::TokenMetadata> = GetTokensMetadataResponse.tokens_metadata;
    }
    match None::<crate::models::InputType>.unwrap() {
        crate::models::InputType::BitcoinAddress(field0) => {
            let _: crate::models::BitcoinAddressDetails = field0;
        }
        crate::models::InputType::Bolt11Invoice(field0) => {
            let _: crate::models::Bolt11InvoiceDetails = field0;
        }
        crate::models::InputType::Bolt12Invoice(field0) => {
            let _: crate::models::Bolt12InvoiceDetails = field0;
        }
        crate::models::InputType::Bolt12Offer(field0) => {
            let _: crate::models::Bolt12OfferDetails = field0;
        }
        crate::models::InputType::LightningAddress(field0) => {
            let _: crate::models::LightningAddressDetails = field0;
        }
        crate::models::InputType::LnurlPay(field0) => {
            let _: crate::models::LnurlPayRequestDetails = field0;
        }
        crate::models::InputType::SilentPaymentAddress(field0) => {
            let _: crate::models::SilentPaymentAddressDetails = field0;
        }
        crate::models::InputType::LnurlAuth(field0) => {
            let _: crate::models::LnurlAuthRequestDetails = field0;
        }
        crate::models::InputType::Url(field0) => {
            let _: String = field0;
        }
        crate::models::InputType::Bip21(field0) => {
            let _: crate::models::Bip21Details = field0;
        }
        crate::models::InputType::Bolt12InvoiceRequest(field0) => {
            let _: crate::models::Bolt12InvoiceRequestDetails = field0;
        }
        crate::models::InputType::LnurlWithdraw(field0) => {
            let _: crate::models::LnurlWithdrawRequestDetails = field0;
        }
        crate::models::InputType::SparkAddress(field0) => {
            let _: crate::models::SparkAddressDetails = field0;
        }
        crate::models::InputType::SparkInvoice(field0) => {
            let _: crate::models::SparkInvoiceDetails = field0;
        }
    }
    {
        let KeySetConfig = None::<crate::models::KeySetConfig>.unwrap();
        let _: crate::models::KeySetType = KeySetConfig.key_set_type;
        let _: bool = KeySetConfig.use_address_index;
        let _: Option<u32> = KeySetConfig.account_number;
    }
    {
        let LightningAddressDetails = None::<crate::models::LightningAddressDetails>.unwrap();
        let _: String = LightningAddressDetails.address;
        let _: crate::models::LnurlPayRequestDetails = LightningAddressDetails.pay_request;
    }
    {
        let LightningAddressInfo = None::<crate::models::LightningAddressInfo>.unwrap();
        let _: String = LightningAddressInfo.description;
        let _: String = LightningAddressInfo.lightning_address;
        let _: String = LightningAddressInfo.lnurl;
        let _: String = LightningAddressInfo.username;
    }
    {
        let ListFiatCurrenciesResponse = None::<crate::models::ListFiatCurrenciesResponse>.unwrap();
        let _: Vec<crate::models::FiatCurrency> = ListFiatCurrenciesResponse.currencies;
    }
    {
        let ListFiatRatesResponse = None::<crate::models::ListFiatRatesResponse>.unwrap();
        let _: Vec<crate::models::Rate> = ListFiatRatesResponse.rates;
    }
    {
        let ListPaymentsRequest = None::<crate::models::ListPaymentsRequest>.unwrap();
        let _: Option<Vec<crate::models::PaymentType>> = ListPaymentsRequest.type_filter;
        let _: Option<Vec<crate::models::PaymentStatus>> = ListPaymentsRequest.status_filter;
        let _: Option<crate::models::AssetFilter> = ListPaymentsRequest.asset_filter;
        let _: Option<Vec<crate::models::PaymentDetailsFilter>> =
            ListPaymentsRequest.payment_details_filter;
        let _: Option<u64> = ListPaymentsRequest.from_timestamp;
        let _: Option<u64> = ListPaymentsRequest.to_timestamp;
        let _: Option<u32> = ListPaymentsRequest.offset;
        let _: Option<u32> = ListPaymentsRequest.limit;
        let _: Option<bool> = ListPaymentsRequest.sort_ascending;
    }
    {
        let ListPaymentsResponse = None::<crate::models::ListPaymentsResponse>.unwrap();
        let _: Vec<crate::models::Payment> = ListPaymentsResponse.payments;
    }
    {
        let ListUnclaimedDepositsRequest =
            None::<crate::models::ListUnclaimedDepositsRequest>.unwrap();
    }
    {
        let ListUnclaimedDepositsResponse =
            None::<crate::models::ListUnclaimedDepositsResponse>.unwrap();
        let _: Vec<crate::models::DepositInfo> = ListUnclaimedDepositsResponse.deposits;
    }
    {
        let LnurlAuthRequestDetails = None::<crate::models::LnurlAuthRequestDetails>.unwrap();
        let _: String = LnurlAuthRequestDetails.k1;
        let _: Option<String> = LnurlAuthRequestDetails.action;
        let _: String = LnurlAuthRequestDetails.domain;
        let _: String = LnurlAuthRequestDetails.url;
    }
    match None::<crate::models::LnurlCallbackStatus>.unwrap() {
        crate::models::LnurlCallbackStatus::Ok => {}
        crate::models::LnurlCallbackStatus::ErrorStatus { error_details } => {
            let _: crate::models::LnurlErrorDetails = error_details;
        }
    }
    {
        let LnurlErrorDetails = None::<crate::models::LnurlErrorDetails>.unwrap();
        let _: String = LnurlErrorDetails.reason;
    }
    {
        let LnurlPayInfo = None::<crate::models::LnurlPayInfo>.unwrap();
        let _: Option<String> = LnurlPayInfo.ln_address;
        let _: Option<String> = LnurlPayInfo.comment;
        let _: Option<String> = LnurlPayInfo.domain;
        let _: Option<String> = LnurlPayInfo.metadata;
        let _: Option<crate::models::SuccessActionProcessed> =
            LnurlPayInfo.processed_success_action;
        let _: Option<crate::models::SuccessAction> = LnurlPayInfo.raw_success_action;
    }
    {
        let LnurlPayRequest = None::<crate::models::LnurlPayRequest>.unwrap();
        let _: crate::models::PrepareLnurlPayResponse = LnurlPayRequest.prepare_response;
        let _: Option<String> = LnurlPayRequest.idempotency_key;
    }
    {
        let LnurlPayRequestDetails = None::<crate::models::LnurlPayRequestDetails>.unwrap();
        let _: String = LnurlPayRequestDetails.callback;
        let _: u64 = LnurlPayRequestDetails.min_sendable;
        let _: u64 = LnurlPayRequestDetails.max_sendable;
        let _: String = LnurlPayRequestDetails.metadata_str;
        let _: u16 = LnurlPayRequestDetails.comment_allowed;
        let _: String = LnurlPayRequestDetails.domain;
        let _: String = LnurlPayRequestDetails.url;
        let _: Option<String> = LnurlPayRequestDetails.address;
        let _: Option<bool> = LnurlPayRequestDetails.allows_nostr;
        let _: Option<String> = LnurlPayRequestDetails.nostr_pubkey;
    }
    {
        let LnurlPayResponse = None::<crate::models::LnurlPayResponse>.unwrap();
        let _: crate::models::Payment = LnurlPayResponse.payment;
        let _: Option<crate::models::SuccessActionProcessed> = LnurlPayResponse.success_action;
    }
    {
        let LnurlReceiveMetadata = None::<crate::models::LnurlReceiveMetadata>.unwrap();
        let _: Option<String> = LnurlReceiveMetadata.nostr_zap_request;
        let _: Option<String> = LnurlReceiveMetadata.nostr_zap_receipt;
        let _: Option<String> = LnurlReceiveMetadata.sender_comment;
    }
    {
        let LnurlWithdrawInfo = None::<crate::models::LnurlWithdrawInfo>.unwrap();
        let _: String = LnurlWithdrawInfo.withdraw_url;
    }
    {
        let LnurlWithdrawRequest = None::<crate::models::LnurlWithdrawRequest>.unwrap();
        let _: u64 = LnurlWithdrawRequest.amount_sats;
        let _: crate::models::LnurlWithdrawRequestDetails = LnurlWithdrawRequest.withdraw_request;
        let _: Option<u32> = LnurlWithdrawRequest.completion_timeout_secs;
    }
    {
        let LnurlWithdrawRequestDetails =
            None::<crate::models::LnurlWithdrawRequestDetails>.unwrap();
        let _: String = LnurlWithdrawRequestDetails.callback;
        let _: String = LnurlWithdrawRequestDetails.k1;
        let _: String = LnurlWithdrawRequestDetails.default_description;
        let _: u64 = LnurlWithdrawRequestDetails.min_withdrawable;
        let _: u64 = LnurlWithdrawRequestDetails.max_withdrawable;
    }
    {
        let LnurlWithdrawResponse = None::<crate::models::LnurlWithdrawResponse>.unwrap();
        let _: String = LnurlWithdrawResponse.payment_request;
        let _: Option<crate::models::Payment> = LnurlWithdrawResponse.payment;
    }
    {
        let LocaleOverrides = None::<crate::models::LocaleOverrides>.unwrap();
        let _: String = LocaleOverrides.locale;
        let _: Option<u32> = LocaleOverrides.spacing;
        let _: crate::models::Symbol = LocaleOverrides.symbol;
    }
    {
        let LocalizedName = None::<crate::models::LocalizedName>.unwrap();
        let _: String = LocalizedName.locale;
        let _: String = LocalizedName.name;
    }
    {
        let LogEntry = None::<crate::logger::LogEntry>.unwrap();
        let _: String = LogEntry.line;
        let _: String = LogEntry.level;
    }
    match None::<crate::models::MaxFee>.unwrap() {
        crate::models::MaxFee::Fixed { amount } => {
            let _: u64 = amount;
        }
        crate::models::MaxFee::Rate { sat_per_vbyte } => {
            let _: u64 = sat_per_vbyte;
        }
        crate::models::MaxFee::NetworkRecommended {
            leeway_sat_per_vbyte,
        } => {
            let _: u64 = leeway_sat_per_vbyte;
        }
    }
    {
        let MessageSuccessActionData = None::<crate::models::MessageSuccessActionData>.unwrap();
        let _: String = MessageSuccessActionData.message;
    }
    {
        let MintIssuerTokenRequest = None::<crate::models::MintIssuerTokenRequest>.unwrap();
        let _: u128 = MintIssuerTokenRequest.amount;
    }
    {
        let OptimizationConfig = None::<crate::models::OptimizationConfig>.unwrap();
        let _: bool = OptimizationConfig.auto_enabled;
        let _: u8 = OptimizationConfig.multiplicity;
    }
    match None::<crate::events::OptimizationEvent>.unwrap() {
        crate::events::OptimizationEvent::Started { total_rounds } => {
            let _: u32 = total_rounds;
        }
        crate::events::OptimizationEvent::RoundCompleted {
            current_round,
            total_rounds,
        } => {
            let _: u32 = current_round;
            let _: u32 = total_rounds;
        }
        crate::events::OptimizationEvent::Completed => {}
        crate::events::OptimizationEvent::Cancelled => {}
        crate::events::OptimizationEvent::Failed { error } => {
            let _: String = error;
        }
        crate::events::OptimizationEvent::Skipped => {}
    }
    {
        let OptimizationProgress = None::<crate::models::OptimizationProgress>.unwrap();
        let _: bool = OptimizationProgress.is_running;
        let _: u32 = OptimizationProgress.current_round;
        let _: u32 = OptimizationProgress.total_rounds;
    }
    {
        let Payment = None::<crate::models::Payment>.unwrap();
        let _: String = Payment.id;
        let _: crate::models::PaymentType = Payment.payment_type;
        let _: crate::models::PaymentStatus = Payment.status;
        let _: u128 = Payment.amount;
        let _: u128 = Payment.fees;
        let _: u64 = Payment.timestamp;
        let _: crate::models::PaymentMethod = Payment.method;
        let _: Option<crate::models::PaymentDetails> = Payment.details;
    }
    match None::<crate::models::PaymentDetails>.unwrap() {
        crate::models::PaymentDetails::Spark {
            invoice_details,
            htlc_details,
            conversion_info,
        } => {
            let _: Option<crate::models::SparkInvoicePaymentDetails> = invoice_details;
            let _: Option<crate::models::SparkHtlcDetails> = htlc_details;
            let _: Option<crate::models::ConversionInfo> = conversion_info;
        }
        crate::models::PaymentDetails::Token {
            metadata,
            tx_hash,
            invoice_details,
            conversion_info,
        } => {
            let _: crate::models::TokenMetadata = metadata;
            let _: String = tx_hash;
            let _: Option<crate::models::SparkInvoicePaymentDetails> = invoice_details;
            let _: Option<crate::models::ConversionInfo> = conversion_info;
        }
        crate::models::PaymentDetails::Lightning {
            description,
            preimage,
            invoice,
            payment_hash,
            destination_pubkey,
            lnurl_pay_info,
            lnurl_withdraw_info,
            lnurl_receive_metadata,
        } => {
            let _: Option<String> = description;
            let _: Option<String> = preimage;
            let _: String = invoice;
            let _: String = payment_hash;
            let _: String = destination_pubkey;
            let _: Option<crate::models::LnurlPayInfo> = lnurl_pay_info;
            let _: Option<crate::models::LnurlWithdrawInfo> = lnurl_withdraw_info;
            let _: Option<crate::models::LnurlReceiveMetadata> = lnurl_receive_metadata;
        }
        crate::models::PaymentDetails::Withdraw { tx_id } => {
            let _: String = tx_id;
        }
        crate::models::PaymentDetails::Deposit { tx_id } => {
            let _: String = tx_id;
        }
    }
    match None::<crate::models::PaymentDetailsFilter>.unwrap() {
        crate::models::PaymentDetailsFilter::Spark {
            htlc_status,
            conversion_refund_needed,
        } => {
            let _: Option<Vec<crate::models::SparkHtlcStatus>> = htlc_status;
            let _: Option<bool> = conversion_refund_needed;
        }
        crate::models::PaymentDetailsFilter::Token {
            conversion_refund_needed,
            tx_hash,
        } => {
            let _: Option<bool> = conversion_refund_needed;
            let _: Option<String> = tx_hash;
        }
    }
    {
        let PaymentRequestSource = None::<crate::models::PaymentRequestSource>.unwrap();
        let _: Option<String> = PaymentRequestSource.bip_21_uri;
        let _: Option<String> = PaymentRequestSource.bip_353_address;
    }
    {
        let PrepareLnurlPayRequest = None::<crate::models::PrepareLnurlPayRequest>.unwrap();
        let _: u64 = PrepareLnurlPayRequest.amount_sats;
        let _: crate::models::LnurlPayRequestDetails = PrepareLnurlPayRequest.pay_request;
        let _: Option<String> = PrepareLnurlPayRequest.comment;
        let _: Option<bool> = PrepareLnurlPayRequest.validate_success_action_url;
    }
    {
        let PrepareLnurlPayResponse = None::<crate::models::PrepareLnurlPayResponse>.unwrap();
        let _: u64 = PrepareLnurlPayResponse.amount_sats;
        let _: Option<String> = PrepareLnurlPayResponse.comment;
        let _: crate::models::LnurlPayRequestDetails = PrepareLnurlPayResponse.pay_request;
        let _: u64 = PrepareLnurlPayResponse.fee_sats;
        let _: crate::models::Bolt11InvoiceDetails = PrepareLnurlPayResponse.invoice_details;
        let _: Option<crate::models::SuccessAction> = PrepareLnurlPayResponse.success_action;
    }
    {
        let PrepareSendPaymentRequest = None::<crate::models::PrepareSendPaymentRequest>.unwrap();
        let _: String = PrepareSendPaymentRequest.payment_request;
        let _: Option<u128> = PrepareSendPaymentRequest.amount;
        let _: Option<String> = PrepareSendPaymentRequest.token_identifier;
        let _: Option<crate::models::ConversionOptions> =
            PrepareSendPaymentRequest.conversion_options;
    }
    {
        let PrepareSendPaymentResponse = None::<crate::models::PrepareSendPaymentResponse>.unwrap();
        let _: crate::models::SendPaymentMethod = PrepareSendPaymentResponse.payment_method;
        let _: u128 = PrepareSendPaymentResponse.amount;
        let _: Option<String> = PrepareSendPaymentResponse.token_identifier;
        let _: Option<crate::models::ConversionEstimate> =
            PrepareSendPaymentResponse.conversion_estimate;
    }
    {
        let Rate = None::<crate::models::Rate>.unwrap();
        let _: String = Rate.coin;
        let _: f64 = Rate.value;
    }
    match None::<crate::models::ReceivePaymentMethod>.unwrap() {
        crate::models::ReceivePaymentMethod::SparkAddress => {}
        crate::models::ReceivePaymentMethod::SparkInvoice {
            amount,
            token_identifier,
            expiry_time,
            description,
            sender_public_key,
        } => {
            let _: Option<u128> = amount;
            let _: Option<String> = token_identifier;
            let _: Option<u64> = expiry_time;
            let _: Option<String> = description;
            let _: Option<String> = sender_public_key;
        }
        crate::models::ReceivePaymentMethod::BitcoinAddress => {}
        crate::models::ReceivePaymentMethod::Bolt11Invoice {
            description,
            amount_sats,
            expiry_secs,
        } => {
            let _: String = description;
            let _: Option<u64> = amount_sats;
            let _: Option<u32> = expiry_secs;
        }
    }
    {
        let ReceivePaymentRequest = None::<crate::models::ReceivePaymentRequest>.unwrap();
        let _: crate::models::ReceivePaymentMethod = ReceivePaymentRequest.payment_method;
    }
    {
        let ReceivePaymentResponse = None::<crate::models::ReceivePaymentResponse>.unwrap();
        let _: String = ReceivePaymentResponse.payment_request;
        let _: u128 = ReceivePaymentResponse.fee;
    }
    {
        let RecommendedFees = None::<crate::models::RecommendedFees>.unwrap();
        let _: u64 = RecommendedFees.fastest_fee;
        let _: u64 = RecommendedFees.half_hour_fee;
        let _: u64 = RecommendedFees.hour_fee;
        let _: u64 = RecommendedFees.economy_fee;
        let _: u64 = RecommendedFees.minimum_fee;
    }
    {
        let RefundDepositRequest = None::<crate::models::RefundDepositRequest>.unwrap();
        let _: String = RefundDepositRequest.txid;
        let _: u32 = RefundDepositRequest.vout;
        let _: String = RefundDepositRequest.destination_address;
        let _: crate::models::Fee = RefundDepositRequest.fee;
    }
    {
        let RefundDepositResponse = None::<crate::models::RefundDepositResponse>.unwrap();
        let _: String = RefundDepositResponse.tx_id;
        let _: String = RefundDepositResponse.tx_hex;
    }
    {
        let RegisterLightningAddressRequest =
            None::<crate::models::RegisterLightningAddressRequest>.unwrap();
        let _: String = RegisterLightningAddressRequest.username;
        let _: Option<String> = RegisterLightningAddressRequest.description;
    }
    match None::<crate::errors::SdkError>.unwrap() {
        crate::errors::SdkError::SparkError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::InsufficientFunds => {}
        crate::errors::SdkError::InvalidUuid(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::InvalidInput(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::NetworkError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::StorageError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::ChainServiceError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::MaxDepositClaimFeeExceeded {
            tx,
            vout,
            max_fee,
            required_fee_sats,
            required_fee_rate_sat_per_vbyte,
        } => {
            let _: String = tx;
            let _: u32 = vout;
            let _: Option<crate::models::Fee> = max_fee;
            let _: u64 = required_fee_sats;
            let _: u64 = required_fee_rate_sat_per_vbyte;
        }
        crate::errors::SdkError::MissingUtxo { tx, vout } => {
            let _: String = tx;
            let _: u32 = vout;
        }
        crate::errors::SdkError::LnurlError(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::Signer(field0) => {
            let _: String = field0;
        }
        crate::errors::SdkError::Generic(field0) => {
            let _: String = field0;
        }
    }
    match None::<crate::events::SdkEvent>.unwrap() {
        crate::events::SdkEvent::Synced => {}
        crate::events::SdkEvent::UnclaimedDeposits { unclaimed_deposits } => {
            let _: Vec<crate::models::DepositInfo> = unclaimed_deposits;
        }
        crate::events::SdkEvent::ClaimedDeposits { claimed_deposits } => {
            let _: Vec<crate::models::DepositInfo> = claimed_deposits;
        }
        crate::events::SdkEvent::PaymentSucceeded { payment } => {
            let _: crate::models::Payment = payment;
        }
        crate::events::SdkEvent::PaymentPending { payment } => {
            let _: crate::models::Payment = payment;
        }
        crate::events::SdkEvent::PaymentFailed { payment } => {
            let _: crate::models::Payment = payment;
        }
        crate::events::SdkEvent::Optimization { optimization_event } => {
            let _: crate::events::OptimizationEvent = optimization_event;
        }
    }
    match None::<crate::models::Seed>.unwrap() {
        crate::models::Seed::Mnemonic {
            mnemonic,
            passphrase,
        } => {
            let _: String = mnemonic;
            let _: Option<String> = passphrase;
        }
        crate::models::Seed::Entropy(field0) => {
            let _: Vec<u8> = field0;
        }
    }
    {
        let SendOnchainFeeQuote = None::<crate::models::SendOnchainFeeQuote>.unwrap();
        let _: String = SendOnchainFeeQuote.id;
        let _: u64 = SendOnchainFeeQuote.expires_at;
        let _: crate::models::SendOnchainSpeedFeeQuote = SendOnchainFeeQuote.speed_fast;
        let _: crate::models::SendOnchainSpeedFeeQuote = SendOnchainFeeQuote.speed_medium;
        let _: crate::models::SendOnchainSpeedFeeQuote = SendOnchainFeeQuote.speed_slow;
    }
    {
        let SendOnchainSpeedFeeQuote = None::<crate::models::SendOnchainSpeedFeeQuote>.unwrap();
        let _: u64 = SendOnchainSpeedFeeQuote.user_fee_sat;
        let _: u64 = SendOnchainSpeedFeeQuote.l1_broadcast_fee_sat;
    }
    match None::<crate::models::SendPaymentMethod>.unwrap() {
        crate::models::SendPaymentMethod::BitcoinAddress { address, fee_quote } => {
            let _: crate::models::BitcoinAddressDetails = address;
            let _: crate::models::SendOnchainFeeQuote = fee_quote;
        }
        crate::models::SendPaymentMethod::Bolt11Invoice {
            invoice_details,
            spark_transfer_fee_sats,
            lightning_fee_sats,
        } => {
            let _: crate::models::Bolt11InvoiceDetails = invoice_details;
            let _: Option<u64> = spark_transfer_fee_sats;
            let _: u64 = lightning_fee_sats;
        }
        crate::models::SendPaymentMethod::SparkAddress {
            address,
            fee,
            token_identifier,
        } => {
            let _: String = address;
            let _: u128 = fee;
            let _: Option<String> = token_identifier;
        }
        crate::models::SendPaymentMethod::SparkInvoice {
            spark_invoice_details,
            fee,
            token_identifier,
        } => {
            let _: crate::models::SparkInvoiceDetails = spark_invoice_details;
            let _: u128 = fee;
            let _: Option<String> = token_identifier;
        }
    }
    match None::<crate::models::SendPaymentOptions>.unwrap() {
        crate::models::SendPaymentOptions::BitcoinAddress { confirmation_speed } => {
            let _: crate::models::OnchainConfirmationSpeed = confirmation_speed;
        }
        crate::models::SendPaymentOptions::Bolt11Invoice {
            prefer_spark,
            completion_timeout_secs,
        } => {
            let _: bool = prefer_spark;
            let _: Option<u32> = completion_timeout_secs;
        }
        crate::models::SendPaymentOptions::SparkAddress { htlc_options } => {
            let _: Option<crate::models::SparkHtlcOptions> = htlc_options;
        }
    }
    {
        let SendPaymentRequest = None::<crate::models::SendPaymentRequest>.unwrap();
        let _: crate::models::PrepareSendPaymentResponse = SendPaymentRequest.prepare_response;
        let _: Option<crate::models::SendPaymentOptions> = SendPaymentRequest.options;
        let _: Option<String> = SendPaymentRequest.idempotency_key;
    }
    {
        let SendPaymentResponse = None::<crate::models::SendPaymentResponse>.unwrap();
        let _: crate::models::Payment = SendPaymentResponse.payment;
    }
    {
        let SignMessageRequest = None::<crate::models::SignMessageRequest>.unwrap();
        let _: String = SignMessageRequest.message;
        let _: bool = SignMessageRequest.compact;
    }
    {
        let SignMessageResponse = None::<crate::models::SignMessageResponse>.unwrap();
        let _: String = SignMessageResponse.pubkey;
        let _: String = SignMessageResponse.signature;
    }
    {
        let SilentPaymentAddressDetails =
            None::<crate::models::SilentPaymentAddressDetails>.unwrap();
        let _: String = SilentPaymentAddressDetails.address;
        let _: crate::models::BitcoinNetwork = SilentPaymentAddressDetails.network;
        let _: crate::models::PaymentRequestSource = SilentPaymentAddressDetails.source;
    }
    {
        let SparkAddressDetails = None::<crate::models::SparkAddressDetails>.unwrap();
        let _: String = SparkAddressDetails.address;
        let _: String = SparkAddressDetails.identity_public_key;
        let _: crate::models::BitcoinNetwork = SparkAddressDetails.network;
        let _: crate::models::PaymentRequestSource = SparkAddressDetails.source;
    }
    {
        let SparkHtlcDetails = None::<crate::models::SparkHtlcDetails>.unwrap();
        let _: String = SparkHtlcDetails.payment_hash;
        let _: Option<String> = SparkHtlcDetails.preimage;
        let _: u64 = SparkHtlcDetails.expiry_time;
        let _: crate::models::SparkHtlcStatus = SparkHtlcDetails.status;
    }
    {
        let SparkHtlcOptions = None::<crate::models::SparkHtlcOptions>.unwrap();
        let _: String = SparkHtlcOptions.payment_hash;
        let _: u64 = SparkHtlcOptions.expiry_duration_secs;
    }
    {
        let SparkInvoiceDetails = None::<crate::models::SparkInvoiceDetails>.unwrap();
        let _: String = SparkInvoiceDetails.invoice;
        let _: String = SparkInvoiceDetails.identity_public_key;
        let _: crate::models::BitcoinNetwork = SparkInvoiceDetails.network;
        let _: Option<u128> = SparkInvoiceDetails.amount;
        let _: Option<String> = SparkInvoiceDetails.token_identifier;
        let _: Option<u64> = SparkInvoiceDetails.expiry_time;
        let _: Option<String> = SparkInvoiceDetails.description;
        let _: Option<String> = SparkInvoiceDetails.sender_public_key;
    }
    {
        let SparkInvoicePaymentDetails = None::<crate::models::SparkInvoicePaymentDetails>.unwrap();
        let _: Option<String> = SparkInvoicePaymentDetails.description;
        let _: String = SparkInvoicePaymentDetails.invoice;
    }
    match None::<crate::models::SuccessAction>.unwrap() {
        crate::models::SuccessAction::Aes { data } => {
            let _: crate::models::AesSuccessActionData = data;
        }
        crate::models::SuccessAction::Message { data } => {
            let _: crate::models::MessageSuccessActionData = data;
        }
        crate::models::SuccessAction::Url { data } => {
            let _: crate::models::UrlSuccessActionData = data;
        }
    }
    match None::<crate::models::SuccessActionProcessed>.unwrap() {
        crate::models::SuccessActionProcessed::Aes { result } => {
            let _: crate::models::AesSuccessActionDataResult = result;
        }
        crate::models::SuccessActionProcessed::Message { data } => {
            let _: crate::models::MessageSuccessActionData = data;
        }
        crate::models::SuccessActionProcessed::Url { data } => {
            let _: crate::models::UrlSuccessActionData = data;
        }
    }
    {
        let Symbol = None::<crate::models::Symbol>.unwrap();
        let _: Option<String> = Symbol.grapheme;
        let _: Option<String> = Symbol.template;
        let _: Option<bool> = Symbol.rtl;
        let _: Option<u32> = Symbol.position;
    }
    {
        let SyncWalletRequest = None::<crate::models::SyncWalletRequest>.unwrap();
    }
    {
        let SyncWalletResponse = None::<crate::models::SyncWalletResponse>.unwrap();
    }
    {
        let TokenBalance = None::<crate::models::TokenBalance>.unwrap();
        let _: u128 = TokenBalance.balance;
        let _: crate::models::TokenMetadata = TokenBalance.token_metadata;
    }
    {
        let TokenMetadata = None::<crate::models::TokenMetadata>.unwrap();
        let _: String = TokenMetadata.identifier;
        let _: String = TokenMetadata.issuer_public_key;
        let _: String = TokenMetadata.name;
        let _: String = TokenMetadata.ticker;
        let _: u32 = TokenMetadata.decimals;
        let _: u128 = TokenMetadata.max_supply;
        let _: bool = TokenMetadata.is_freezable;
    }
    {
        let UnfreezeIssuerTokenRequest = None::<crate::models::UnfreezeIssuerTokenRequest>.unwrap();
        let _: String = UnfreezeIssuerTokenRequest.address;
    }
    {
        let UnfreezeIssuerTokenResponse =
            None::<crate::models::UnfreezeIssuerTokenResponse>.unwrap();
        let _: Vec<String> = UnfreezeIssuerTokenResponse.impacted_output_ids;
        let _: u128 = UnfreezeIssuerTokenResponse.impacted_token_amount;
    }
    {
        let UpdateUserSettingsRequest = None::<crate::models::UpdateUserSettingsRequest>.unwrap();
        let _: Option<bool> = UpdateUserSettingsRequest.spark_private_mode_enabled;
    }
    {
        let UrlSuccessActionData = None::<crate::models::UrlSuccessActionData>.unwrap();
        let _: String = UrlSuccessActionData.description;
        let _: String = UrlSuccessActionData.url;
        let _: bool = UrlSuccessActionData.matches_callback_domain;
    }
    {
        let UserSettings = None::<crate::models::UserSettings>.unwrap();
        let _: bool = UserSettings.spark_private_mode_enabled;
    }
};

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for BreezSdk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TokenIssuer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, crate::models::TokenBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, crate::models::TokenBalance)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for StreamSink<crate::logger::LogEntry, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::events::SdkEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return inner.parse().unwrap();
    }
}

impl SseDecode for crate::models::AesSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_ciphertext = <String>::sse_decode(deserializer);
        let mut var_iv = <String>::sse_decode(deserializer);
        return crate::models::AesSuccessActionData {
            description: var_description,
            ciphertext: var_ciphertext,
            iv: var_iv,
        };
    }
}

impl SseDecode for crate::models::AesSuccessActionDataDecrypted {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_plaintext = <String>::sse_decode(deserializer);
        return crate::models::AesSuccessActionDataDecrypted {
            description: var_description,
            plaintext: var_plaintext,
        };
    }
}

impl SseDecode for crate::models::AesSuccessActionDataResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_data =
                    <crate::models::AesSuccessActionDataDecrypted>::sse_decode(deserializer);
                return crate::models::AesSuccessActionDataResult::Decrypted { data: var_data };
            }
            1 => {
                let mut var_reason = <String>::sse_decode(deserializer);
                return crate::models::AesSuccessActionDataResult::ErrorStatus {
                    reason: var_reason,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Amount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                return crate::models::Amount::Bitcoin {
                    amount_msat: var_amountMsat,
                };
            }
            1 => {
                let mut var_iso4217Code = <String>::sse_decode(deserializer);
                let mut var_fractionalAmount = <u64>::sse_decode(deserializer);
                return crate::models::Amount::Currency {
                    iso4217_code: var_iso4217Code,
                    fractional_amount: var_fractionalAmount,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::AssetFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::AssetFilter::Bitcoin;
            }
            1 => {
                let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
                return crate::models::AssetFilter::Token {
                    token_identifier: var_tokenIdentifier,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Bip21Details {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountSat = <Option<u64>>::sse_decode(deserializer);
        let mut var_assetId = <Option<String>>::sse_decode(deserializer);
        let mut var_uri = <String>::sse_decode(deserializer);
        let mut var_extras = <Vec<crate::models::Bip21Extra>>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_message = <Option<String>>::sse_decode(deserializer);
        let mut var_paymentMethods = <Vec<crate::models::InputType>>::sse_decode(deserializer);
        return crate::models::Bip21Details {
            amount_sat: var_amountSat,
            asset_id: var_assetId,
            uri: var_uri,
            extras: var_extras,
            label: var_label,
            message: var_message,
            payment_methods: var_paymentMethods,
        };
    }
}

impl SseDecode for crate::models::Bip21Extra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_key = <String>::sse_decode(deserializer);
        let mut var_value = <String>::sse_decode(deserializer);
        return crate::models::Bip21Extra {
            key: var_key,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::BitcoinAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::BitcoinAddressDetails {
            address: var_address,
            network: var_network,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::BitcoinNetwork {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::BitcoinNetwork::Bitcoin,
            1 => crate::models::BitcoinNetwork::Testnet3,
            2 => crate::models::BitcoinNetwork::Testnet4,
            3 => crate::models::BitcoinNetwork::Signet,
            4 => crate::models::BitcoinNetwork::Regtest,
            _ => unreachable!("Invalid variant for BitcoinNetwork: {}", inner),
        };
    }
}

impl SseDecode for crate::models::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bolt11 = <String>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::Bolt11Invoice {
            bolt11: var_bolt11,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::Bolt11InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_descriptionHash = <Option<String>>::sse_decode(deserializer);
        let mut var_expiry = <u64>::sse_decode(deserializer);
        let mut var_invoice = <crate::models::Bolt11Invoice>::sse_decode(deserializer);
        let mut var_minFinalCltvExpiryDelta = <u64>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_payeePubkey = <String>::sse_decode(deserializer);
        let mut var_paymentHash = <String>::sse_decode(deserializer);
        let mut var_paymentSecret = <String>::sse_decode(deserializer);
        let mut var_routingHints = <Vec<crate::models::Bolt11RouteHint>>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return crate::models::Bolt11InvoiceDetails {
            amount_msat: var_amountMsat,
            description: var_description,
            description_hash: var_descriptionHash,
            expiry: var_expiry,
            invoice: var_invoice,
            min_final_cltv_expiry_delta: var_minFinalCltvExpiryDelta,
            network: var_network,
            payee_pubkey: var_payeePubkey,
            payment_hash: var_paymentHash,
            payment_secret: var_paymentSecret,
            routing_hints: var_routingHints,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::models::Bolt11RouteHint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hops = <Vec<crate::models::Bolt11RouteHintHop>>::sse_decode(deserializer);
        return crate::models::Bolt11RouteHint { hops: var_hops };
    }
}

impl SseDecode for crate::models::Bolt11RouteHintHop {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_srcNodeId = <String>::sse_decode(deserializer);
        let mut var_shortChannelId = <String>::sse_decode(deserializer);
        let mut var_feesBaseMsat = <u32>::sse_decode(deserializer);
        let mut var_feesProportionalMillionths = <u32>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_htlcMinimumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_htlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        return crate::models::Bolt11RouteHintHop {
            src_node_id: var_srcNodeId,
            short_channel_id: var_shortChannelId,
            fees_base_msat: var_feesBaseMsat,
            fees_proportional_millionths: var_feesProportionalMillionths,
            cltv_expiry_delta: var_cltvExpiryDelta,
            htlc_minimum_msat: var_htlcMinimumMsat,
            htlc_maximum_msat: var_htlcMaximumMsat,
        };
    }
}

impl SseDecode for crate::models::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::Bolt12Invoice {
            invoice: var_invoice,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::Bolt12InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountMsat = <u64>::sse_decode(deserializer);
        let mut var_invoice = <crate::models::Bolt12Invoice>::sse_decode(deserializer);
        return crate::models::Bolt12InvoiceDetails {
            amount_msat: var_amountMsat,
            invoice: var_invoice,
        };
    }
}

impl SseDecode for crate::models::Bolt12InvoiceRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::Bolt12InvoiceRequestDetails {};
    }
}

impl SseDecode for crate::models::Bolt12Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_offer = <String>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::Bolt12Offer {
            offer: var_offer,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::Bolt12OfferBlindedPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blindedHops = <Vec<String>>::sse_decode(deserializer);
        return crate::models::Bolt12OfferBlindedPath {
            blinded_hops: var_blindedHops,
        };
    }
}

impl SseDecode for crate::models::Bolt12OfferDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_absoluteExpiry = <Option<u64>>::sse_decode(deserializer);
        let mut var_chains = <Vec<String>>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_issuer = <Option<String>>::sse_decode(deserializer);
        let mut var_minAmount = <Option<crate::models::Amount>>::sse_decode(deserializer);
        let mut var_offer = <crate::models::Bolt12Offer>::sse_decode(deserializer);
        let mut var_paths = <Vec<crate::models::Bolt12OfferBlindedPath>>::sse_decode(deserializer);
        let mut var_signingPubkey = <Option<String>>::sse_decode(deserializer);
        return crate::models::Bolt12OfferDetails {
            absolute_expiry: var_absoluteExpiry,
            chains: var_chains,
            description: var_description,
            issuer: var_issuer,
            min_amount: var_minAmount,
            offer: var_offer,
            paths: var_paths,
            signing_pubkey: var_signingPubkey,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::BurnIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amount = <u128>::sse_decode(deserializer);
        return crate::models::BurnIssuerTokenRequest { amount: var_amount };
    }
}

impl SseDecode for crate::models::ChainApiType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::ChainApiType::Esplora,
            1 => crate::models::ChainApiType::MempoolSpace,
            _ => unreachable!("Invalid variant for ChainApiType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::CheckLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        return crate::models::CheckLightningAddressRequest {
            username: var_username,
        };
    }
}

impl SseDecode for crate::models::CheckMessageRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_pubkey = <String>::sse_decode(deserializer);
        let mut var_signature = <String>::sse_decode(deserializer);
        return crate::models::CheckMessageRequest {
            message: var_message,
            pubkey: var_pubkey,
            signature: var_signature,
        };
    }
}

impl SseDecode for crate::models::CheckMessageResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isValid = <bool>::sse_decode(deserializer);
        return crate::models::CheckMessageResponse {
            is_valid: var_isValid,
        };
    }
}

impl SseDecode for crate::models::ClaimDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        let mut var_maxFee = <Option<crate::models::MaxFee>>::sse_decode(deserializer);
        return crate::models::ClaimDepositRequest {
            txid: var_txid,
            vout: var_vout,
            max_fee: var_maxFee,
        };
    }
}

impl SseDecode for crate::models::ClaimDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::ClaimDepositResponse {
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::ClaimHtlcPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_preimage = <String>::sse_decode(deserializer);
        return crate::models::ClaimHtlcPaymentRequest {
            preimage: var_preimage,
        };
    }
}

impl SseDecode for crate::models::ClaimHtlcPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::ClaimHtlcPaymentResponse {
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_apiKey = <Option<String>>::sse_decode(deserializer);
        let mut var_network = <crate::models::Network>::sse_decode(deserializer);
        let mut var_syncIntervalSecs = <u32>::sse_decode(deserializer);
        let mut var_maxDepositClaimFee = <Option<crate::models::MaxFee>>::sse_decode(deserializer);
        let mut var_lnurlDomain = <Option<String>>::sse_decode(deserializer);
        let mut var_preferSparkOverLightning = <bool>::sse_decode(deserializer);
        let mut var_externalInputParsers =
            <Option<Vec<crate::models::ExternalInputParser>>>::sse_decode(deserializer);
        let mut var_useDefaultExternalInputParsers = <bool>::sse_decode(deserializer);
        let mut var_realTimeSyncServerUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_privateEnabledDefault = <bool>::sse_decode(deserializer);
        let mut var_optimizationConfig =
            <crate::models::OptimizationConfig>::sse_decode(deserializer);
        return crate::models::Config {
            api_key: var_apiKey,
            network: var_network,
            sync_interval_secs: var_syncIntervalSecs,
            max_deposit_claim_fee: var_maxDepositClaimFee,
            lnurl_domain: var_lnurlDomain,
            prefer_spark_over_lightning: var_preferSparkOverLightning,
            external_input_parsers: var_externalInputParsers,
            use_default_external_input_parsers: var_useDefaultExternalInputParsers,
            real_time_sync_server_url: var_realTimeSyncServerUrl,
            private_enabled_default: var_privateEnabledDefault,
            optimization_config: var_optimizationConfig,
        };
    }
}

impl SseDecode for crate::models::ConnectRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_config = <crate::models::Config>::sse_decode(deserializer);
        let mut var_seed = <crate::models::Seed>::sse_decode(deserializer);
        let mut var_storageDir = <String>::sse_decode(deserializer);
        return crate::models::ConnectRequest {
            config: var_config,
            seed: var_seed,
            storage_dir: var_storageDir,
        };
    }
}

impl SseDecode for crate::models::ConversionEstimate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_options = <crate::models::ConversionOptions>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_fee = <u128>::sse_decode(deserializer);
        return crate::models::ConversionEstimate {
            options: var_options,
            amount: var_amount,
            fee: var_fee,
        };
    }
}

impl SseDecode for crate::models::ConversionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_poolId = <String>::sse_decode(deserializer);
        let mut var_conversionId = <String>::sse_decode(deserializer);
        let mut var_status = <crate::models::ConversionStatus>::sse_decode(deserializer);
        let mut var_fee = <Option<u128>>::sse_decode(deserializer);
        let mut var_purpose = <Option<crate::models::ConversionPurpose>>::sse_decode(deserializer);
        return crate::models::ConversionInfo {
            pool_id: var_poolId,
            conversion_id: var_conversionId,
            status: var_status,
            fee: var_fee,
            purpose: var_purpose,
        };
    }
}

impl SseDecode for crate::models::ConversionOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_conversionType = <crate::models::ConversionType>::sse_decode(deserializer);
        let mut var_maxSlippageBps = <Option<u32>>::sse_decode(deserializer);
        let mut var_completionTimeoutSecs = <Option<u32>>::sse_decode(deserializer);
        return crate::models::ConversionOptions {
            conversion_type: var_conversionType,
            max_slippage_bps: var_maxSlippageBps,
            completion_timeout_secs: var_completionTimeoutSecs,
        };
    }
}

impl SseDecode for crate::models::ConversionPurpose {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_paymentRequest = <String>::sse_decode(deserializer);
                return crate::models::ConversionPurpose::OngoingPayment {
                    payment_request: var_paymentRequest,
                };
            }
            1 => {
                return crate::models::ConversionPurpose::SelfTransfer;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::ConversionStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::ConversionStatus::Completed,
            1 => crate::models::ConversionStatus::RefundNeeded,
            2 => crate::models::ConversionStatus::Refunded,
            _ => unreachable!("Invalid variant for ConversionStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::models::ConversionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::ConversionType::FromBitcoin;
            }
            1 => {
                let mut var_fromTokenIdentifier = <String>::sse_decode(deserializer);
                return crate::models::ConversionType::ToBitcoin {
                    from_token_identifier: var_fromTokenIdentifier,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::CreateIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_ticker = <String>::sse_decode(deserializer);
        let mut var_decimals = <u32>::sse_decode(deserializer);
        let mut var_isFreezable = <bool>::sse_decode(deserializer);
        let mut var_maxSupply = <u128>::sse_decode(deserializer);
        return crate::models::CreateIssuerTokenRequest {
            name: var_name,
            ticker: var_ticker,
            decimals: var_decimals,
            is_freezable: var_isFreezable,
            max_supply: var_maxSupply,
        };
    }
}

impl SseDecode for crate::models::Credentials {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_password = <String>::sse_decode(deserializer);
        return crate::models::Credentials {
            username: var_username,
            password: var_password,
        };
    }
}

impl SseDecode for crate::models::CurrencyInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_fractionSize = <u32>::sse_decode(deserializer);
        let mut var_spacing = <Option<u32>>::sse_decode(deserializer);
        let mut var_symbol = <Option<crate::models::Symbol>>::sse_decode(deserializer);
        let mut var_uniqSymbol = <Option<crate::models::Symbol>>::sse_decode(deserializer);
        let mut var_localizedName = <Vec<crate::models::LocalizedName>>::sse_decode(deserializer);
        let mut var_localeOverrides =
            <Vec<crate::models::LocaleOverrides>>::sse_decode(deserializer);
        return crate::models::CurrencyInfo {
            name: var_name,
            fraction_size: var_fractionSize,
            spacing: var_spacing,
            symbol: var_symbol,
            uniq_symbol: var_uniqSymbol,
            localized_name: var_localizedName,
            locale_overrides: var_localeOverrides,
        };
    }
}

impl SseDecode for crate::errors::DepositClaimError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                let mut var_maxFee = <Option<crate::models::Fee>>::sse_decode(deserializer);
                let mut var_requiredFeeSats = <u64>::sse_decode(deserializer);
                let mut var_requiredFeeRateSatPerVbyte = <u64>::sse_decode(deserializer);
                return crate::errors::DepositClaimError::MaxDepositClaimFeeExceeded {
                    tx: var_tx,
                    vout: var_vout,
                    max_fee: var_maxFee,
                    required_fee_sats: var_requiredFeeSats,
                    required_fee_rate_sat_per_vbyte: var_requiredFeeRateSatPerVbyte,
                };
            }
            1 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                return crate::errors::DepositClaimError::MissingUtxo {
                    tx: var_tx,
                    vout: var_vout,
                };
            }
            2 => {
                let mut var_message = <String>::sse_decode(deserializer);
                return crate::errors::DepositClaimError::Generic {
                    message: var_message,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::DepositInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_refundTx = <Option<String>>::sse_decode(deserializer);
        let mut var_refundTxId = <Option<String>>::sse_decode(deserializer);
        let mut var_claimError =
            <Option<crate::errors::DepositClaimError>>::sse_decode(deserializer);
        return crate::models::DepositInfo {
            txid: var_txid,
            vout: var_vout,
            amount_sats: var_amountSats,
            refund_tx: var_refundTx,
            refund_tx_id: var_refundTxId,
            claim_error: var_claimError,
        };
    }
}

impl SseDecode for crate::models::ExternalInputParser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_providerId = <String>::sse_decode(deserializer);
        let mut var_inputRegex = <String>::sse_decode(deserializer);
        let mut var_parserUrl = <String>::sse_decode(deserializer);
        return crate::models::ExternalInputParser {
            provider_id: var_providerId,
            input_regex: var_inputRegex,
            parser_url: var_parserUrl,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::Fee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_amount = <u64>::sse_decode(deserializer);
                return crate::models::Fee::Fixed { amount: var_amount };
            }
            1 => {
                let mut var_satPerVbyte = <u64>::sse_decode(deserializer);
                return crate::models::Fee::Rate {
                    sat_per_vbyte: var_satPerVbyte,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::FetchConversionLimitsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_conversionType = <crate::models::ConversionType>::sse_decode(deserializer);
        let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
        return crate::models::FetchConversionLimitsRequest {
            conversion_type: var_conversionType,
            token_identifier: var_tokenIdentifier,
        };
    }
}

impl SseDecode for crate::models::FetchConversionLimitsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_minFromAmount = <Option<u128>>::sse_decode(deserializer);
        let mut var_minToAmount = <Option<u128>>::sse_decode(deserializer);
        return crate::models::FetchConversionLimitsResponse {
            min_from_amount: var_minFromAmount,
            min_to_amount: var_minToAmount,
        };
    }
}

impl SseDecode for crate::models::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_info = <crate::models::CurrencyInfo>::sse_decode(deserializer);
        return crate::models::FiatCurrency {
            id: var_id,
            info: var_info,
        };
    }
}

impl SseDecode for crate::models::FreezeIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        return crate::models::FreezeIssuerTokenRequest {
            address: var_address,
        };
    }
}

impl SseDecode for crate::models::FreezeIssuerTokenResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_impactedOutputIds = <Vec<String>>::sse_decode(deserializer);
        let mut var_impactedTokenAmount = <u128>::sse_decode(deserializer);
        return crate::models::FreezeIssuerTokenResponse {
            impacted_output_ids: var_impactedOutputIds,
            impacted_token_amount: var_impactedTokenAmount,
        };
    }
}

impl SseDecode for crate::models::GetInfoRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ensureSynced = <Option<bool>>::sse_decode(deserializer);
        return crate::models::GetInfoRequest {
            ensure_synced: var_ensureSynced,
        };
    }
}

impl SseDecode for crate::models::GetInfoResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_balanceSats = <u64>::sse_decode(deserializer);
        let mut var_tokenBalances =
            <std::collections::HashMap<String, crate::models::TokenBalance>>::sse_decode(
                deserializer,
            );
        return crate::models::GetInfoResponse {
            balance_sats: var_balanceSats,
            token_balances: var_tokenBalances,
        };
    }
}

impl SseDecode for crate::models::GetPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentId = <String>::sse_decode(deserializer);
        return crate::models::GetPaymentRequest {
            payment_id: var_paymentId,
        };
    }
}

impl SseDecode for crate::models::GetPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::GetPaymentResponse {
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::GetTokensMetadataRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tokenIdentifiers = <Vec<String>>::sse_decode(deserializer);
        return crate::models::GetTokensMetadataRequest {
            token_identifiers: var_tokenIdentifiers,
        };
    }
}

impl SseDecode for crate::models::GetTokensMetadataResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tokensMetadata = <Vec<crate::models::TokenMetadata>>::sse_decode(deserializer);
        return crate::models::GetTokensMetadataResponse {
            tokens_metadata: var_tokensMetadata,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::InputType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <crate::models::BitcoinAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::BitcoinAddress(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <crate::models::Bolt11InvoiceDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt11Invoice(var_field0);
            }
            2 => {
                let mut var_field0 =
                    <crate::models::Bolt12InvoiceDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt12Invoice(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::models::Bolt12OfferDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt12Offer(var_field0);
            }
            4 => {
                let mut var_field0 =
                    <crate::models::LightningAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::LightningAddress(var_field0);
            }
            5 => {
                let mut var_field0 =
                    <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::LnurlPay(var_field0);
            }
            6 => {
                let mut var_field0 =
                    <crate::models::SilentPaymentAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::SilentPaymentAddress(var_field0);
            }
            7 => {
                let mut var_field0 =
                    <crate::models::LnurlAuthRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::LnurlAuth(var_field0);
            }
            8 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::models::InputType::Url(var_field0);
            }
            9 => {
                let mut var_field0 = <crate::models::Bip21Details>::sse_decode(deserializer);
                return crate::models::InputType::Bip21(var_field0);
            }
            10 => {
                let mut var_field0 =
                    <crate::models::Bolt12InvoiceRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::Bolt12InvoiceRequest(var_field0);
            }
            11 => {
                let mut var_field0 =
                    <crate::models::LnurlWithdrawRequestDetails>::sse_decode(deserializer);
                return crate::models::InputType::LnurlWithdraw(var_field0);
            }
            12 => {
                let mut var_field0 = <crate::models::SparkAddressDetails>::sse_decode(deserializer);
                return crate::models::InputType::SparkAddress(var_field0);
            }
            13 => {
                let mut var_field0 = <crate::models::SparkInvoiceDetails>::sse_decode(deserializer);
                return crate::models::InputType::SparkInvoice(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::KeySetConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_keySetType = <crate::models::KeySetType>::sse_decode(deserializer);
        let mut var_useAddressIndex = <bool>::sse_decode(deserializer);
        let mut var_accountNumber = <Option<u32>>::sse_decode(deserializer);
        return crate::models::KeySetConfig {
            key_set_type: var_keySetType,
            use_address_index: var_useAddressIndex,
            account_number: var_accountNumber,
        };
    }
}

impl SseDecode for crate::models::KeySetType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::KeySetType::Default,
            1 => crate::models::KeySetType::Taproot,
            2 => crate::models::KeySetType::NativeSegwit,
            3 => crate::models::KeySetType::WrappedSegwit,
            4 => crate::models::KeySetType::Legacy,
            _ => unreachable!("Invalid variant for KeySetType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::LightningAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_payRequest = <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
        return crate::models::LightningAddressDetails {
            address: var_address,
            pay_request: var_payRequest,
        };
    }
}

impl SseDecode for crate::models::LightningAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_lightningAddress = <String>::sse_decode(deserializer);
        let mut var_lnurl = <String>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        return crate::models::LightningAddressInfo {
            description: var_description,
            lightning_address: var_lightningAddress,
            lnurl: var_lnurl,
            username: var_username,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bip21Extra> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bip21Extra>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bolt11RouteHint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bolt11RouteHint>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bolt11RouteHintHop> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bolt11RouteHintHop>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Bolt12OfferBlindedPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Bolt12OfferBlindedPath>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::DepositInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::DepositInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::ExternalInputParser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::ExternalInputParser>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListFiatCurrenciesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_currencies = <Vec<crate::models::FiatCurrency>>::sse_decode(deserializer);
        return crate::models::ListFiatCurrenciesResponse {
            currencies: var_currencies,
        };
    }
}

impl SseDecode for Vec<crate::models::FiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::FiatCurrency>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListFiatRatesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rates = <Vec<crate::models::Rate>>::sse_decode(deserializer);
        return crate::models::ListFiatRatesResponse { rates: var_rates };
    }
}

impl SseDecode for Vec<crate::models::InputType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::InputType>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::LocaleOverrides> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::LocaleOverrides>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::LocalizedName> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::LocalizedName>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Payment>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::PaymentDetailsFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::PaymentDetailsFilter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::PaymentStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::PaymentStatus>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::PaymentType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::PaymentType>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListPaymentsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_typeFilter =
            <Option<Vec<crate::models::PaymentType>>>::sse_decode(deserializer);
        let mut var_statusFilter =
            <Option<Vec<crate::models::PaymentStatus>>>::sse_decode(deserializer);
        let mut var_assetFilter = <Option<crate::models::AssetFilter>>::sse_decode(deserializer);
        let mut var_paymentDetailsFilter =
            <Option<Vec<crate::models::PaymentDetailsFilter>>>::sse_decode(deserializer);
        let mut var_fromTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_toTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_offset = <Option<u32>>::sse_decode(deserializer);
        let mut var_limit = <Option<u32>>::sse_decode(deserializer);
        let mut var_sortAscending = <Option<bool>>::sse_decode(deserializer);
        return crate::models::ListPaymentsRequest {
            type_filter: var_typeFilter,
            status_filter: var_statusFilter,
            asset_filter: var_assetFilter,
            payment_details_filter: var_paymentDetailsFilter,
            from_timestamp: var_fromTimestamp,
            to_timestamp: var_toTimestamp,
            offset: var_offset,
            limit: var_limit,
            sort_ascending: var_sortAscending,
        };
    }
}

impl SseDecode for crate::models::ListPaymentsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payments = <Vec<crate::models::Payment>>::sse_decode(deserializer);
        return crate::models::ListPaymentsResponse {
            payments: var_payments,
        };
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Rate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Rate>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::models::TokenBalance)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, crate::models::TokenBalance)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::SparkHtlcStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::SparkHtlcStatus>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::TokenMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::TokenMetadata>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::ListUnclaimedDepositsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::ListUnclaimedDepositsRequest {};
    }
}

impl SseDecode for crate::models::ListUnclaimedDepositsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deposits = <Vec<crate::models::DepositInfo>>::sse_decode(deserializer);
        return crate::models::ListUnclaimedDepositsResponse {
            deposits: var_deposits,
        };
    }
}

impl SseDecode for crate::models::LnurlAuthRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_k1 = <String>::sse_decode(deserializer);
        let mut var_action = <Option<String>>::sse_decode(deserializer);
        let mut var_domain = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        return crate::models::LnurlAuthRequestDetails {
            k1: var_k1,
            action: var_action,
            domain: var_domain,
            url: var_url,
        };
    }
}

impl SseDecode for crate::models::LnurlCallbackStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::LnurlCallbackStatus::Ok;
            }
            1 => {
                let mut var_errorDetails =
                    <crate::models::LnurlErrorDetails>::sse_decode(deserializer);
                return crate::models::LnurlCallbackStatus::ErrorStatus {
                    error_details: var_errorDetails,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::LnurlErrorDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_reason = <String>::sse_decode(deserializer);
        return crate::models::LnurlErrorDetails { reason: var_reason };
    }
}

impl SseDecode for crate::models::LnurlPayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lnAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_comment = <Option<String>>::sse_decode(deserializer);
        let mut var_domain = <Option<String>>::sse_decode(deserializer);
        let mut var_metadata = <Option<String>>::sse_decode(deserializer);
        let mut var_processedSuccessAction =
            <Option<crate::models::SuccessActionProcessed>>::sse_decode(deserializer);
        let mut var_rawSuccessAction =
            <Option<crate::models::SuccessAction>>::sse_decode(deserializer);
        return crate::models::LnurlPayInfo {
            ln_address: var_lnAddress,
            comment: var_comment,
            domain: var_domain,
            metadata: var_metadata,
            processed_success_action: var_processedSuccessAction,
            raw_success_action: var_rawSuccessAction,
        };
    }
}

impl SseDecode for crate::models::LnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prepareResponse =
            <crate::models::PrepareLnurlPayResponse>::sse_decode(deserializer);
        let mut var_idempotencyKey = <Option<String>>::sse_decode(deserializer);
        return crate::models::LnurlPayRequest {
            prepare_response: var_prepareResponse,
            idempotency_key: var_idempotencyKey,
        };
    }
}

impl SseDecode for crate::models::LnurlPayRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_callback = <String>::sse_decode(deserializer);
        let mut var_minSendable = <u64>::sse_decode(deserializer);
        let mut var_maxSendable = <u64>::sse_decode(deserializer);
        let mut var_metadataStr = <String>::sse_decode(deserializer);
        let mut var_commentAllowed = <u16>::sse_decode(deserializer);
        let mut var_domain = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_address = <Option<String>>::sse_decode(deserializer);
        let mut var_allowsNostr = <Option<bool>>::sse_decode(deserializer);
        let mut var_nostrPubkey = <Option<String>>::sse_decode(deserializer);
        return crate::models::LnurlPayRequestDetails {
            callback: var_callback,
            min_sendable: var_minSendable,
            max_sendable: var_maxSendable,
            metadata_str: var_metadataStr,
            comment_allowed: var_commentAllowed,
            domain: var_domain,
            url: var_url,
            address: var_address,
            allows_nostr: var_allowsNostr,
            nostr_pubkey: var_nostrPubkey,
        };
    }
}

impl SseDecode for crate::models::LnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        let mut var_successAction =
            <Option<crate::models::SuccessActionProcessed>>::sse_decode(deserializer);
        return crate::models::LnurlPayResponse {
            payment: var_payment,
            success_action: var_successAction,
        };
    }
}

impl SseDecode for crate::models::LnurlReceiveMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nostrZapRequest = <Option<String>>::sse_decode(deserializer);
        let mut var_nostrZapReceipt = <Option<String>>::sse_decode(deserializer);
        let mut var_senderComment = <Option<String>>::sse_decode(deserializer);
        return crate::models::LnurlReceiveMetadata {
            nostr_zap_request: var_nostrZapRequest,
            nostr_zap_receipt: var_nostrZapReceipt,
            sender_comment: var_senderComment,
        };
    }
}

impl SseDecode for crate::models::LnurlWithdrawInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_withdrawUrl = <String>::sse_decode(deserializer);
        return crate::models::LnurlWithdrawInfo {
            withdraw_url: var_withdrawUrl,
        };
    }
}

impl SseDecode for crate::models::LnurlWithdrawRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_withdrawRequest =
            <crate::models::LnurlWithdrawRequestDetails>::sse_decode(deserializer);
        let mut var_completionTimeoutSecs = <Option<u32>>::sse_decode(deserializer);
        return crate::models::LnurlWithdrawRequest {
            amount_sats: var_amountSats,
            withdraw_request: var_withdrawRequest,
            completion_timeout_secs: var_completionTimeoutSecs,
        };
    }
}

impl SseDecode for crate::models::LnurlWithdrawRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_callback = <String>::sse_decode(deserializer);
        let mut var_k1 = <String>::sse_decode(deserializer);
        let mut var_defaultDescription = <String>::sse_decode(deserializer);
        let mut var_minWithdrawable = <u64>::sse_decode(deserializer);
        let mut var_maxWithdrawable = <u64>::sse_decode(deserializer);
        return crate::models::LnurlWithdrawRequestDetails {
            callback: var_callback,
            k1: var_k1,
            default_description: var_defaultDescription,
            min_withdrawable: var_minWithdrawable,
            max_withdrawable: var_maxWithdrawable,
        };
    }
}

impl SseDecode for crate::models::LnurlWithdrawResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentRequest = <String>::sse_decode(deserializer);
        let mut var_payment = <Option<crate::models::Payment>>::sse_decode(deserializer);
        return crate::models::LnurlWithdrawResponse {
            payment_request: var_paymentRequest,
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::LocaleOverrides {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_locale = <String>::sse_decode(deserializer);
        let mut var_spacing = <Option<u32>>::sse_decode(deserializer);
        let mut var_symbol = <crate::models::Symbol>::sse_decode(deserializer);
        return crate::models::LocaleOverrides {
            locale: var_locale,
            spacing: var_spacing,
            symbol: var_symbol,
        };
    }
}

impl SseDecode for crate::models::LocalizedName {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_locale = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::models::LocalizedName {
            locale: var_locale,
            name: var_name,
        };
    }
}

impl SseDecode for crate::logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_line = <String>::sse_decode(deserializer);
        let mut var_level = <String>::sse_decode(deserializer);
        return crate::logger::LogEntry {
            line: var_line,
            level: var_level,
        };
    }
}

impl SseDecode for crate::models::MaxFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_amount = <u64>::sse_decode(deserializer);
                return crate::models::MaxFee::Fixed { amount: var_amount };
            }
            1 => {
                let mut var_satPerVbyte = <u64>::sse_decode(deserializer);
                return crate::models::MaxFee::Rate {
                    sat_per_vbyte: var_satPerVbyte,
                };
            }
            2 => {
                let mut var_leewaySatPerVbyte = <u64>::sse_decode(deserializer);
                return crate::models::MaxFee::NetworkRecommended {
                    leeway_sat_per_vbyte: var_leewaySatPerVbyte,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::MessageSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::models::MessageSuccessActionData {
            message: var_message,
        };
    }
}

impl SseDecode for crate::models::MintIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amount = <u128>::sse_decode(deserializer);
        return crate::models::MintIssuerTokenRequest { amount: var_amount };
    }
}

impl SseDecode for crate::models::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::Network::Mainnet,
            1 => crate::models::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for crate::models::OnchainConfirmationSpeed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::OnchainConfirmationSpeed::Fast,
            1 => crate::models::OnchainConfirmationSpeed::Medium,
            2 => crate::models::OnchainConfirmationSpeed::Slow,
            _ => unreachable!("Invalid variant for OnchainConfirmationSpeed: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u128>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Amount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Amount>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::AssetFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::AssetFilter>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::ConversionEstimate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::ConversionEstimate>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::ConversionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::ConversionInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::ConversionOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::ConversionOptions>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::ConversionPurpose> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::ConversionPurpose>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Credentials> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Credentials>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::errors::DepositClaimError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::errors::DepositClaimError>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Fee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Fee>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::LightningAddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::LightningAddressInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::LnurlPayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::LnurlPayInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::LnurlReceiveMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::LnurlReceiveMetadata>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::LnurlWithdrawInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::LnurlWithdrawInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::MaxFee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::MaxFee>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Payment>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::PaymentDetails>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SendPaymentOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SendPaymentOptions>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SparkHtlcDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SparkHtlcDetails>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SparkHtlcOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SparkHtlcOptions>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SparkInvoicePaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SparkInvoicePaymentDetails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SuccessAction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SuccessAction>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::SuccessActionProcessed> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::SuccessActionProcessed>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::Symbol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::Symbol>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::ExternalInputParser>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::ExternalInputParser>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::PaymentDetailsFilter>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::PaymentDetailsFilter>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::PaymentStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::PaymentStatus>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::PaymentType>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::PaymentType>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::SparkHtlcStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::SparkHtlcStatus>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::OptimizationConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_autoEnabled = <bool>::sse_decode(deserializer);
        let mut var_multiplicity = <u8>::sse_decode(deserializer);
        return crate::models::OptimizationConfig {
            auto_enabled: var_autoEnabled,
            multiplicity: var_multiplicity,
        };
    }
}

impl SseDecode for crate::events::OptimizationEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_totalRounds = <u32>::sse_decode(deserializer);
                return crate::events::OptimizationEvent::Started {
                    total_rounds: var_totalRounds,
                };
            }
            1 => {
                let mut var_currentRound = <u32>::sse_decode(deserializer);
                let mut var_totalRounds = <u32>::sse_decode(deserializer);
                return crate::events::OptimizationEvent::RoundCompleted {
                    current_round: var_currentRound,
                    total_rounds: var_totalRounds,
                };
            }
            2 => {
                return crate::events::OptimizationEvent::Completed;
            }
            3 => {
                return crate::events::OptimizationEvent::Cancelled;
            }
            4 => {
                let mut var_error = <String>::sse_decode(deserializer);
                return crate::events::OptimizationEvent::Failed { error: var_error };
            }
            5 => {
                return crate::events::OptimizationEvent::Skipped;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::OptimizationProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isRunning = <bool>::sse_decode(deserializer);
        let mut var_currentRound = <u32>::sse_decode(deserializer);
        let mut var_totalRounds = <u32>::sse_decode(deserializer);
        return crate::models::OptimizationProgress {
            is_running: var_isRunning,
            current_round: var_currentRound,
            total_rounds: var_totalRounds,
        };
    }
}

impl SseDecode for crate::models::Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_paymentType = <crate::models::PaymentType>::sse_decode(deserializer);
        let mut var_status = <crate::models::PaymentStatus>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_fees = <u128>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_method = <crate::models::PaymentMethod>::sse_decode(deserializer);
        let mut var_details = <Option<crate::models::PaymentDetails>>::sse_decode(deserializer);
        return crate::models::Payment {
            id: var_id,
            payment_type: var_paymentType,
            status: var_status,
            amount: var_amount,
            fees: var_fees,
            timestamp: var_timestamp,
            method: var_method,
            details: var_details,
        };
    }
}

impl SseDecode for crate::models::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_invoiceDetails =
                    <Option<crate::models::SparkInvoicePaymentDetails>>::sse_decode(deserializer);
                let mut var_htlcDetails =
                    <Option<crate::models::SparkHtlcDetails>>::sse_decode(deserializer);
                let mut var_conversionInfo =
                    <Option<crate::models::ConversionInfo>>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Spark {
                    invoice_details: var_invoiceDetails,
                    htlc_details: var_htlcDetails,
                    conversion_info: var_conversionInfo,
                };
            }
            1 => {
                let mut var_metadata = <crate::models::TokenMetadata>::sse_decode(deserializer);
                let mut var_txHash = <String>::sse_decode(deserializer);
                let mut var_invoiceDetails =
                    <Option<crate::models::SparkInvoicePaymentDetails>>::sse_decode(deserializer);
                let mut var_conversionInfo =
                    <Option<crate::models::ConversionInfo>>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Token {
                    metadata: var_metadata,
                    tx_hash: var_txHash,
                    invoice_details: var_invoiceDetails,
                    conversion_info: var_conversionInfo,
                };
            }
            2 => {
                let mut var_description = <Option<String>>::sse_decode(deserializer);
                let mut var_preimage = <Option<String>>::sse_decode(deserializer);
                let mut var_invoice = <String>::sse_decode(deserializer);
                let mut var_paymentHash = <String>::sse_decode(deserializer);
                let mut var_destinationPubkey = <String>::sse_decode(deserializer);
                let mut var_lnurlPayInfo =
                    <Option<crate::models::LnurlPayInfo>>::sse_decode(deserializer);
                let mut var_lnurlWithdrawInfo =
                    <Option<crate::models::LnurlWithdrawInfo>>::sse_decode(deserializer);
                let mut var_lnurlReceiveMetadata =
                    <Option<crate::models::LnurlReceiveMetadata>>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Lightning {
                    description: var_description,
                    preimage: var_preimage,
                    invoice: var_invoice,
                    payment_hash: var_paymentHash,
                    destination_pubkey: var_destinationPubkey,
                    lnurl_pay_info: var_lnurlPayInfo,
                    lnurl_withdraw_info: var_lnurlWithdrawInfo,
                    lnurl_receive_metadata: var_lnurlReceiveMetadata,
                };
            }
            3 => {
                let mut var_txId = <String>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Withdraw { tx_id: var_txId };
            }
            4 => {
                let mut var_txId = <String>::sse_decode(deserializer);
                return crate::models::PaymentDetails::Deposit { tx_id: var_txId };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::PaymentDetailsFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_htlcStatus =
                    <Option<Vec<crate::models::SparkHtlcStatus>>>::sse_decode(deserializer);
                let mut var_conversionRefundNeeded = <Option<bool>>::sse_decode(deserializer);
                return crate::models::PaymentDetailsFilter::Spark {
                    htlc_status: var_htlcStatus,
                    conversion_refund_needed: var_conversionRefundNeeded,
                };
            }
            1 => {
                let mut var_conversionRefundNeeded = <Option<bool>>::sse_decode(deserializer);
                let mut var_txHash = <Option<String>>::sse_decode(deserializer);
                return crate::models::PaymentDetailsFilter::Token {
                    conversion_refund_needed: var_conversionRefundNeeded,
                    tx_hash: var_txHash,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::PaymentMethod::Lightning,
            1 => crate::models::PaymentMethod::Spark,
            2 => crate::models::PaymentMethod::Token,
            3 => crate::models::PaymentMethod::Deposit,
            4 => crate::models::PaymentMethod::Withdraw,
            5 => crate::models::PaymentMethod::Unknown,
            _ => unreachable!("Invalid variant for PaymentMethod: {}", inner),
        };
    }
}

impl SseDecode for crate::models::PaymentRequestSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bip21Uri = <Option<String>>::sse_decode(deserializer);
        let mut var_bip353Address = <Option<String>>::sse_decode(deserializer);
        return crate::models::PaymentRequestSource {
            bip_21_uri: var_bip21Uri,
            bip_353_address: var_bip353Address,
        };
    }
}

impl SseDecode for crate::models::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::PaymentStatus::Completed,
            1 => crate::models::PaymentStatus::Pending,
            2 => crate::models::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::models::PaymentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::PaymentType::Send,
            1 => crate::models::PaymentType::Receive,
            _ => unreachable!("Invalid variant for PaymentType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::PrepareLnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_payRequest = <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
        let mut var_comment = <Option<String>>::sse_decode(deserializer);
        let mut var_validateSuccessActionUrl = <Option<bool>>::sse_decode(deserializer);
        return crate::models::PrepareLnurlPayRequest {
            amount_sats: var_amountSats,
            pay_request: var_payRequest,
            comment: var_comment,
            validate_success_action_url: var_validateSuccessActionUrl,
        };
    }
}

impl SseDecode for crate::models::PrepareLnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_comment = <Option<String>>::sse_decode(deserializer);
        let mut var_payRequest = <crate::models::LnurlPayRequestDetails>::sse_decode(deserializer);
        let mut var_feeSats = <u64>::sse_decode(deserializer);
        let mut var_invoiceDetails =
            <crate::models::Bolt11InvoiceDetails>::sse_decode(deserializer);
        let mut var_successAction =
            <Option<crate::models::SuccessAction>>::sse_decode(deserializer);
        return crate::models::PrepareLnurlPayResponse {
            amount_sats: var_amountSats,
            comment: var_comment,
            pay_request: var_payRequest,
            fee_sats: var_feeSats,
            invoice_details: var_invoiceDetails,
            success_action: var_successAction,
        };
    }
}

impl SseDecode for crate::models::PrepareSendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentRequest = <String>::sse_decode(deserializer);
        let mut var_amount = <Option<u128>>::sse_decode(deserializer);
        let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
        let mut var_conversionOptions =
            <Option<crate::models::ConversionOptions>>::sse_decode(deserializer);
        return crate::models::PrepareSendPaymentRequest {
            payment_request: var_paymentRequest,
            amount: var_amount,
            token_identifier: var_tokenIdentifier,
            conversion_options: var_conversionOptions,
        };
    }
}

impl SseDecode for crate::models::PrepareSendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentMethod = <crate::models::SendPaymentMethod>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
        let mut var_conversionEstimate =
            <Option<crate::models::ConversionEstimate>>::sse_decode(deserializer);
        return crate::models::PrepareSendPaymentResponse {
            payment_method: var_paymentMethod,
            amount: var_amount,
            token_identifier: var_tokenIdentifier,
            conversion_estimate: var_conversionEstimate,
        };
    }
}

impl SseDecode for crate::models::Rate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_coin = <String>::sse_decode(deserializer);
        let mut var_value = <f64>::sse_decode(deserializer);
        return crate::models::Rate {
            coin: var_coin,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::ReceivePaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::ReceivePaymentMethod::SparkAddress;
            }
            1 => {
                let mut var_amount = <Option<u128>>::sse_decode(deserializer);
                let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
                let mut var_expiryTime = <Option<u64>>::sse_decode(deserializer);
                let mut var_description = <Option<String>>::sse_decode(deserializer);
                let mut var_senderPublicKey = <Option<String>>::sse_decode(deserializer);
                return crate::models::ReceivePaymentMethod::SparkInvoice {
                    amount: var_amount,
                    token_identifier: var_tokenIdentifier,
                    expiry_time: var_expiryTime,
                    description: var_description,
                    sender_public_key: var_senderPublicKey,
                };
            }
            2 => {
                return crate::models::ReceivePaymentMethod::BitcoinAddress;
            }
            3 => {
                let mut var_description = <String>::sse_decode(deserializer);
                let mut var_amountSats = <Option<u64>>::sse_decode(deserializer);
                let mut var_expirySecs = <Option<u32>>::sse_decode(deserializer);
                return crate::models::ReceivePaymentMethod::Bolt11Invoice {
                    description: var_description,
                    amount_sats: var_amountSats,
                    expiry_secs: var_expirySecs,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::ReceivePaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentMethod = <crate::models::ReceivePaymentMethod>::sse_decode(deserializer);
        return crate::models::ReceivePaymentRequest {
            payment_method: var_paymentMethod,
        };
    }
}

impl SseDecode for crate::models::ReceivePaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentRequest = <String>::sse_decode(deserializer);
        let mut var_fee = <u128>::sse_decode(deserializer);
        return crate::models::ReceivePaymentResponse {
            payment_request: var_paymentRequest,
            fee: var_fee,
        };
    }
}

impl SseDecode for crate::models::RecommendedFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fastestFee = <u64>::sse_decode(deserializer);
        let mut var_halfHourFee = <u64>::sse_decode(deserializer);
        let mut var_hourFee = <u64>::sse_decode(deserializer);
        let mut var_economyFee = <u64>::sse_decode(deserializer);
        let mut var_minimumFee = <u64>::sse_decode(deserializer);
        return crate::models::RecommendedFees {
            fastest_fee: var_fastestFee,
            half_hour_fee: var_halfHourFee,
            hour_fee: var_hourFee,
            economy_fee: var_economyFee,
            minimum_fee: var_minimumFee,
        };
    }
}

impl SseDecode for (String, crate::models::TokenBalance) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::models::TokenBalance>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::models::RefundDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        let mut var_destinationAddress = <String>::sse_decode(deserializer);
        let mut var_fee = <crate::models::Fee>::sse_decode(deserializer);
        return crate::models::RefundDepositRequest {
            txid: var_txid,
            vout: var_vout,
            destination_address: var_destinationAddress,
            fee: var_fee,
        };
    }
}

impl SseDecode for crate::models::RefundDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txId = <String>::sse_decode(deserializer);
        let mut var_txHex = <String>::sse_decode(deserializer);
        return crate::models::RefundDepositResponse {
            tx_id: var_txId,
            tx_hex: var_txHex,
        };
    }
}

impl SseDecode for crate::models::RegisterLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        return crate::models::RegisterLightningAddressRequest {
            username: var_username,
            description: var_description,
        };
    }
}

impl SseDecode for crate::errors::SdkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::SparkError(var_field0);
            }
            1 => {
                return crate::errors::SdkError::InsufficientFunds;
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::InvalidUuid(var_field0);
            }
            3 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::InvalidInput(var_field0);
            }
            4 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::NetworkError(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::StorageError(var_field0);
            }
            6 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::ChainServiceError(var_field0);
            }
            7 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                let mut var_maxFee = <Option<crate::models::Fee>>::sse_decode(deserializer);
                let mut var_requiredFeeSats = <u64>::sse_decode(deserializer);
                let mut var_requiredFeeRateSatPerVbyte = <u64>::sse_decode(deserializer);
                return crate::errors::SdkError::MaxDepositClaimFeeExceeded {
                    tx: var_tx,
                    vout: var_vout,
                    max_fee: var_maxFee,
                    required_fee_sats: var_requiredFeeSats,
                    required_fee_rate_sat_per_vbyte: var_requiredFeeRateSatPerVbyte,
                };
            }
            8 => {
                let mut var_tx = <String>::sse_decode(deserializer);
                let mut var_vout = <u32>::sse_decode(deserializer);
                return crate::errors::SdkError::MissingUtxo {
                    tx: var_tx,
                    vout: var_vout,
                };
            }
            9 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::LnurlError(var_field0);
            }
            10 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::Signer(var_field0);
            }
            11 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::errors::SdkError::Generic(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::events::SdkEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::events::SdkEvent::Synced;
            }
            1 => {
                let mut var_unclaimedDeposits =
                    <Vec<crate::models::DepositInfo>>::sse_decode(deserializer);
                return crate::events::SdkEvent::UnclaimedDeposits {
                    unclaimed_deposits: var_unclaimedDeposits,
                };
            }
            2 => {
                let mut var_claimedDeposits =
                    <Vec<crate::models::DepositInfo>>::sse_decode(deserializer);
                return crate::events::SdkEvent::ClaimedDeposits {
                    claimed_deposits: var_claimedDeposits,
                };
            }
            3 => {
                let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
                return crate::events::SdkEvent::PaymentSucceeded {
                    payment: var_payment,
                };
            }
            4 => {
                let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
                return crate::events::SdkEvent::PaymentPending {
                    payment: var_payment,
                };
            }
            5 => {
                let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
                return crate::events::SdkEvent::PaymentFailed {
                    payment: var_payment,
                };
            }
            6 => {
                let mut var_optimizationEvent =
                    <crate::events::OptimizationEvent>::sse_decode(deserializer);
                return crate::events::SdkEvent::Optimization {
                    optimization_event: var_optimizationEvent,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Seed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_mnemonic = <String>::sse_decode(deserializer);
                let mut var_passphrase = <Option<String>>::sse_decode(deserializer);
                return crate::models::Seed::Mnemonic {
                    mnemonic: var_mnemonic,
                    passphrase: var_passphrase,
                };
            }
            1 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::models::Seed::Entropy(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SendOnchainFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_expiresAt = <u64>::sse_decode(deserializer);
        let mut var_speedFast = <crate::models::SendOnchainSpeedFeeQuote>::sse_decode(deserializer);
        let mut var_speedMedium =
            <crate::models::SendOnchainSpeedFeeQuote>::sse_decode(deserializer);
        let mut var_speedSlow = <crate::models::SendOnchainSpeedFeeQuote>::sse_decode(deserializer);
        return crate::models::SendOnchainFeeQuote {
            id: var_id,
            expires_at: var_expiresAt,
            speed_fast: var_speedFast,
            speed_medium: var_speedMedium,
            speed_slow: var_speedSlow,
        };
    }
}

impl SseDecode for crate::models::SendOnchainSpeedFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_userFeeSat = <u64>::sse_decode(deserializer);
        let mut var_l1BroadcastFeeSat = <u64>::sse_decode(deserializer);
        return crate::models::SendOnchainSpeedFeeQuote {
            user_fee_sat: var_userFeeSat,
            l1_broadcast_fee_sat: var_l1BroadcastFeeSat,
        };
    }
}

impl SseDecode for crate::models::SendPaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_address =
                    <crate::models::BitcoinAddressDetails>::sse_decode(deserializer);
                let mut var_feeQuote =
                    <crate::models::SendOnchainFeeQuote>::sse_decode(deserializer);
                return crate::models::SendPaymentMethod::BitcoinAddress {
                    address: var_address,
                    fee_quote: var_feeQuote,
                };
            }
            1 => {
                let mut var_invoiceDetails =
                    <crate::models::Bolt11InvoiceDetails>::sse_decode(deserializer);
                let mut var_sparkTransferFeeSats = <Option<u64>>::sse_decode(deserializer);
                let mut var_lightningFeeSats = <u64>::sse_decode(deserializer);
                return crate::models::SendPaymentMethod::Bolt11Invoice {
                    invoice_details: var_invoiceDetails,
                    spark_transfer_fee_sats: var_sparkTransferFeeSats,
                    lightning_fee_sats: var_lightningFeeSats,
                };
            }
            2 => {
                let mut var_address = <String>::sse_decode(deserializer);
                let mut var_fee = <u128>::sse_decode(deserializer);
                let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
                return crate::models::SendPaymentMethod::SparkAddress {
                    address: var_address,
                    fee: var_fee,
                    token_identifier: var_tokenIdentifier,
                };
            }
            3 => {
                let mut var_sparkInvoiceDetails =
                    <crate::models::SparkInvoiceDetails>::sse_decode(deserializer);
                let mut var_fee = <u128>::sse_decode(deserializer);
                let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
                return crate::models::SendPaymentMethod::SparkInvoice {
                    spark_invoice_details: var_sparkInvoiceDetails,
                    fee: var_fee,
                    token_identifier: var_tokenIdentifier,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SendPaymentOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_confirmationSpeed =
                    <crate::models::OnchainConfirmationSpeed>::sse_decode(deserializer);
                return crate::models::SendPaymentOptions::BitcoinAddress {
                    confirmation_speed: var_confirmationSpeed,
                };
            }
            1 => {
                let mut var_preferSpark = <bool>::sse_decode(deserializer);
                let mut var_completionTimeoutSecs = <Option<u32>>::sse_decode(deserializer);
                return crate::models::SendPaymentOptions::Bolt11Invoice {
                    prefer_spark: var_preferSpark,
                    completion_timeout_secs: var_completionTimeoutSecs,
                };
            }
            2 => {
                let mut var_htlcOptions =
                    <Option<crate::models::SparkHtlcOptions>>::sse_decode(deserializer);
                return crate::models::SendPaymentOptions::SparkAddress {
                    htlc_options: var_htlcOptions,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prepareResponse =
            <crate::models::PrepareSendPaymentResponse>::sse_decode(deserializer);
        let mut var_options = <Option<crate::models::SendPaymentOptions>>::sse_decode(deserializer);
        let mut var_idempotencyKey = <Option<String>>::sse_decode(deserializer);
        return crate::models::SendPaymentRequest {
            prepare_response: var_prepareResponse,
            options: var_options,
            idempotency_key: var_idempotencyKey,
        };
    }
}

impl SseDecode for crate::models::SendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payment = <crate::models::Payment>::sse_decode(deserializer);
        return crate::models::SendPaymentResponse {
            payment: var_payment,
        };
    }
}

impl SseDecode for crate::models::SignMessageRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_compact = <bool>::sse_decode(deserializer);
        return crate::models::SignMessageRequest {
            message: var_message,
            compact: var_compact,
        };
    }
}

impl SseDecode for crate::models::SignMessageResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pubkey = <String>::sse_decode(deserializer);
        let mut var_signature = <String>::sse_decode(deserializer);
        return crate::models::SignMessageResponse {
            pubkey: var_pubkey,
            signature: var_signature,
        };
    }
}

impl SseDecode for crate::models::SilentPaymentAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::SilentPaymentAddressDetails {
            address: var_address,
            network: var_network,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::SparkAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_identityPublicKey = <String>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_source = <crate::models::PaymentRequestSource>::sse_decode(deserializer);
        return crate::models::SparkAddressDetails {
            address: var_address,
            identity_public_key: var_identityPublicKey,
            network: var_network,
            source: var_source,
        };
    }
}

impl SseDecode for crate::models::SparkHtlcDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentHash = <String>::sse_decode(deserializer);
        let mut var_preimage = <Option<String>>::sse_decode(deserializer);
        let mut var_expiryTime = <u64>::sse_decode(deserializer);
        let mut var_status = <crate::models::SparkHtlcStatus>::sse_decode(deserializer);
        return crate::models::SparkHtlcDetails {
            payment_hash: var_paymentHash,
            preimage: var_preimage,
            expiry_time: var_expiryTime,
            status: var_status,
        };
    }
}

impl SseDecode for crate::models::SparkHtlcOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paymentHash = <String>::sse_decode(deserializer);
        let mut var_expiryDurationSecs = <u64>::sse_decode(deserializer);
        return crate::models::SparkHtlcOptions {
            payment_hash: var_paymentHash,
            expiry_duration_secs: var_expiryDurationSecs,
        };
    }
}

impl SseDecode for crate::models::SparkHtlcStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::SparkHtlcStatus::WaitingForPreimage,
            1 => crate::models::SparkHtlcStatus::PreimageShared,
            2 => crate::models::SparkHtlcStatus::Returned,
            _ => unreachable!("Invalid variant for SparkHtlcStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::models::SparkInvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_identityPublicKey = <String>::sse_decode(deserializer);
        let mut var_network = <crate::models::BitcoinNetwork>::sse_decode(deserializer);
        let mut var_amount = <Option<u128>>::sse_decode(deserializer);
        let mut var_tokenIdentifier = <Option<String>>::sse_decode(deserializer);
        let mut var_expiryTime = <Option<u64>>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_senderPublicKey = <Option<String>>::sse_decode(deserializer);
        return crate::models::SparkInvoiceDetails {
            invoice: var_invoice,
            identity_public_key: var_identityPublicKey,
            network: var_network,
            amount: var_amount,
            token_identifier: var_tokenIdentifier,
            expiry_time: var_expiryTime,
            description: var_description,
            sender_public_key: var_senderPublicKey,
        };
    }
}

impl SseDecode for crate::models::SparkInvoicePaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        return crate::models::SparkInvoicePaymentDetails {
            description: var_description,
            invoice: var_invoice,
        };
    }
}

impl SseDecode for crate::models::SuccessAction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_data = <crate::models::AesSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessAction::Aes { data: var_data };
            }
            1 => {
                let mut var_data =
                    <crate::models::MessageSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessAction::Message { data: var_data };
            }
            2 => {
                let mut var_data = <crate::models::UrlSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessAction::Url { data: var_data };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::SuccessActionProcessed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_result =
                    <crate::models::AesSuccessActionDataResult>::sse_decode(deserializer);
                return crate::models::SuccessActionProcessed::Aes { result: var_result };
            }
            1 => {
                let mut var_data =
                    <crate::models::MessageSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessActionProcessed::Message { data: var_data };
            }
            2 => {
                let mut var_data = <crate::models::UrlSuccessActionData>::sse_decode(deserializer);
                return crate::models::SuccessActionProcessed::Url { data: var_data };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::Symbol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_grapheme = <Option<String>>::sse_decode(deserializer);
        let mut var_template = <Option<String>>::sse_decode(deserializer);
        let mut var_rtl = <Option<bool>>::sse_decode(deserializer);
        let mut var_position = <Option<u32>>::sse_decode(deserializer);
        return crate::models::Symbol {
            grapheme: var_grapheme,
            template: var_template,
            rtl: var_rtl,
            position: var_position,
        };
    }
}

impl SseDecode for crate::models::SyncWalletRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::SyncWalletRequest {};
    }
}

impl SseDecode for crate::models::SyncWalletResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::models::SyncWalletResponse {};
    }
}

impl SseDecode for crate::models::TokenBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_balance = <u128>::sse_decode(deserializer);
        let mut var_tokenMetadata = <crate::models::TokenMetadata>::sse_decode(deserializer);
        return crate::models::TokenBalance {
            balance: var_balance,
            token_metadata: var_tokenMetadata,
        };
    }
}

impl SseDecode for crate::models::TokenMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_identifier = <String>::sse_decode(deserializer);
        let mut var_issuerPublicKey = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_ticker = <String>::sse_decode(deserializer);
        let mut var_decimals = <u32>::sse_decode(deserializer);
        let mut var_maxSupply = <u128>::sse_decode(deserializer);
        let mut var_isFreezable = <bool>::sse_decode(deserializer);
        return crate::models::TokenMetadata {
            identifier: var_identifier,
            issuer_public_key: var_issuerPublicKey,
            name: var_name,
            ticker: var_ticker,
            decimals: var_decimals,
            max_supply: var_maxSupply,
            is_freezable: var_isFreezable,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for crate::models::UnfreezeIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        return crate::models::UnfreezeIssuerTokenRequest {
            address: var_address,
        };
    }
}

impl SseDecode for crate::models::UnfreezeIssuerTokenResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_impactedOutputIds = <Vec<String>>::sse_decode(deserializer);
        let mut var_impactedTokenAmount = <u128>::sse_decode(deserializer);
        return crate::models::UnfreezeIssuerTokenResponse {
            impacted_output_ids: var_impactedOutputIds,
            impacted_token_amount: var_impactedTokenAmount,
        };
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::models::UpdateUserSettingsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sparkPrivateModeEnabled = <Option<bool>>::sse_decode(deserializer);
        return crate::models::UpdateUserSettingsRequest {
            spark_private_mode_enabled: var_sparkPrivateModeEnabled,
        };
    }
}

impl SseDecode for crate::models::UrlSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_matchesCallbackDomain = <bool>::sse_decode(deserializer);
        return crate::models::UrlSuccessActionData {
            description: var_description,
            url: var_url,
            matches_callback_domain: var_matchesCallbackDomain,
        };
    }
}

impl SseDecode for crate::models::UserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sparkPrivateModeEnabled = <bool>::sse_decode(deserializer);
        return crate::models::UserSettings {
            spark_private_mode_enabled: var_sparkPrivateModeEnabled,
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__sdk__BreezSdk_add_event_listener_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__sdk__BreezSdk_cancel_leaf_optimization_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        3 => wire__crate__sdk__BreezSdk_check_lightning_address_available_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        4 => wire__crate__sdk__BreezSdk_check_message_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__sdk__BreezSdk_claim_deposit_impl(port, ptr, rust_vec_len, data_len),
        6 => wire__crate__sdk__BreezSdk_claim_htlc_payment_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__sdk__BreezSdk_delete_lightning_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        8 => wire__crate__sdk__BreezSdk_disconnect_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__sdk__BreezSdk_fetch_conversion_limits_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => wire__crate__sdk__BreezSdk_get_info_impl(port, ptr, rust_vec_len, data_len),
        12 => {
            wire__crate__sdk__BreezSdk_get_lightning_address_impl(port, ptr, rust_vec_len, data_len)
        }
        13 => wire__crate__sdk__BreezSdk_get_payment_impl(port, ptr, rust_vec_len, data_len),
        15 => {
            wire__crate__sdk__BreezSdk_get_tokens_metadata_impl(port, ptr, rust_vec_len, data_len)
        }
        16 => wire__crate__sdk__BreezSdk_get_user_settings_impl(port, ptr, rust_vec_len, data_len),
        17 => {
            wire__crate__sdk__BreezSdk_list_fiat_currencies_impl(port, ptr, rust_vec_len, data_len)
        }
        18 => wire__crate__sdk__BreezSdk_list_fiat_rates_impl(port, ptr, rust_vec_len, data_len),
        19 => wire__crate__sdk__BreezSdk_list_payments_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__sdk__BreezSdk_list_unclaimed_deposits_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        21 => wire__crate__sdk__BreezSdk_lnurl_auth_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__sdk__BreezSdk_lnurl_pay_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__sdk__BreezSdk_lnurl_withdraw_impl(port, ptr, rust_vec_len, data_len),
        24 => wire__crate__sdk__BreezSdk_parse_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__sdk__BreezSdk_prepare_lnurl_pay_impl(port, ptr, rust_vec_len, data_len),
        26 => {
            wire__crate__sdk__BreezSdk_prepare_send_payment_impl(port, ptr, rust_vec_len, data_len)
        }
        27 => wire__crate__sdk__BreezSdk_receive_payment_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__sdk__BreezSdk_recommended_fees_impl(port, ptr, rust_vec_len, data_len),
        29 => wire__crate__sdk__BreezSdk_refund_deposit_impl(port, ptr, rust_vec_len, data_len),
        30 => wire__crate__sdk__BreezSdk_register_lightning_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        31 => {
            wire__crate__sdk__BreezSdk_remove_event_listener_impl(port, ptr, rust_vec_len, data_len)
        }
        32 => wire__crate__sdk__BreezSdk_send_payment_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__sdk__BreezSdk_sign_message_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__sdk__BreezSdk_sync_wallet_impl(port, ptr, rust_vec_len, data_len),
        36 => {
            wire__crate__sdk__BreezSdk_update_user_settings_impl(port, ptr, rust_vec_len, data_len)
        }
        37 => wire__crate__sdk_builder__SdkBuilder_build_impl(port, ptr, rust_vec_len, data_len),
        42 => wire__crate__issuer__TokenIssuer_burn_issuer_token_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        43 => wire__crate__issuer__TokenIssuer_create_issuer_token_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        44 => wire__crate__issuer__TokenIssuer_freeze_issuer_token_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        45 => wire__crate__issuer__TokenIssuer_get_issuer_token_balance_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        46 => wire__crate__issuer__TokenIssuer_get_issuer_token_metadata_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        47 => wire__crate__issuer__TokenIssuer_mint_issuer_token_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        48 => wire__crate__issuer__TokenIssuer_unfreeze_issuer_token_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        49 => wire__crate__sdk__connect_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        11 => wire__crate__sdk__BreezSdk_get_leaf_optimization_progress_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__sdk__BreezSdk_get_token_issuer_impl(ptr, rust_vec_len, data_len),
        34 => wire__crate__sdk__BreezSdk_start_leaf_optimization_impl(ptr, rust_vec_len, data_len),
        38 => wire__crate__sdk_builder__SdkBuilder_new_impl(ptr, rust_vec_len, data_len),
        39 => wire__crate__sdk_builder__SdkBuilder_with_default_storage_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        40 => wire__crate__sdk_builder__SdkBuilder_with_key_set_impl(ptr, rust_vec_len, data_len),
        41 => wire__crate__sdk_builder__SdkBuilder_with_rest_chain_service_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        50 => wire__crate__sdk__default_config_impl(ptr, rust_vec_len, data_len),
        51 => wire__crate__sdk__init_logging_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BreezSdk> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BreezSdk> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BreezSdk>> for BreezSdk {
    fn into_into_dart(self) -> FrbWrapper<BreezSdk> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SdkBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SdkBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SdkBuilder>> for SdkBuilder {
    fn into_into_dart(self) -> FrbWrapper<SdkBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TokenIssuer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TokenIssuer> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TokenIssuer>> for TokenIssuer {
    fn into_into_dart(self) -> FrbWrapper<TokenIssuer> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AesSuccessActionData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.ciphertext.into_into_dart().into_dart(),
            self.0.iv.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AesSuccessActionData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AesSuccessActionData>>
    for crate::models::AesSuccessActionData
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AesSuccessActionData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AesSuccessActionDataDecrypted> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.plaintext.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AesSuccessActionDataDecrypted>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AesSuccessActionDataDecrypted>>
    for crate::models::AesSuccessActionDataDecrypted
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AesSuccessActionDataDecrypted> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AesSuccessActionDataResult> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::AesSuccessActionDataResult::Decrypted { data } => {
                [0.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::AesSuccessActionDataResult::ErrorStatus { reason } => {
                [1.into_dart(), reason.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AesSuccessActionDataResult>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AesSuccessActionDataResult>>
    for crate::models::AesSuccessActionDataResult
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AesSuccessActionDataResult> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Amount> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Amount::Bitcoin { amount_msat } => {
                [0.into_dart(), amount_msat.into_into_dart().into_dart()].into_dart()
            }
            crate::models::Amount::Currency {
                iso4217_code,
                fractional_amount,
            } => [
                1.into_dart(),
                iso4217_code.into_into_dart().into_dart(),
                fractional_amount.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Amount>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Amount>>
    for crate::models::Amount
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Amount> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::AssetFilter> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::AssetFilter::Bitcoin => [0.into_dart()].into_dart(),
            crate::models::AssetFilter::Token { token_identifier } => {
                [1.into_dart(), token_identifier.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::AssetFilter>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::AssetFilter>>
    for crate::models::AssetFilter
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::AssetFilter> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bip21Details> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_sat.into_into_dart().into_dart(),
            self.0.asset_id.into_into_dart().into_dart(),
            self.0.uri.into_into_dart().into_dart(),
            self.0.extras.into_into_dart().into_dart(),
            self.0.label.into_into_dart().into_dart(),
            self.0.message.into_into_dart().into_dart(),
            self.0.payment_methods.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bip21Details>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bip21Details>>
    for crate::models::Bip21Details
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bip21Details> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bip21Extra> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.key.into_into_dart().into_dart(),
            self.0.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bip21Extra>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bip21Extra>>
    for crate::models::Bip21Extra
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bip21Extra> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::BitcoinAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::BitcoinAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::BitcoinAddressDetails>>
    for crate::models::BitcoinAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::BitcoinAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::BitcoinNetwork> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::BitcoinNetwork::Bitcoin => 0.into_dart(),
            crate::models::BitcoinNetwork::Testnet3 => 1.into_dart(),
            crate::models::BitcoinNetwork::Testnet4 => 2.into_dart(),
            crate::models::BitcoinNetwork::Signet => 3.into_dart(),
            crate::models::BitcoinNetwork::Regtest => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::BitcoinNetwork>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::BitcoinNetwork>>
    for crate::models::BitcoinNetwork
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::BitcoinNetwork> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.bolt11.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11Invoice>>
    for crate::models::Bolt11Invoice
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11InvoiceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_msat.into_into_dart().into_dart(),
            self.0.description.into_into_dart().into_dart(),
            self.0.description_hash.into_into_dart().into_dart(),
            self.0.expiry.into_into_dart().into_dart(),
            self.0.invoice.into_into_dart().into_dart(),
            self.0
                .min_final_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.payee_pubkey.into_into_dart().into_dart(),
            self.0.payment_hash.into_into_dart().into_dart(),
            self.0.payment_secret.into_into_dart().into_dart(),
            self.0.routing_hints.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11InvoiceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11InvoiceDetails>>
    for crate::models::Bolt11InvoiceDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11InvoiceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11RouteHint> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hops.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11RouteHint>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11RouteHint>>
    for crate::models::Bolt11RouteHint
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11RouteHint> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt11RouteHintHop> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.src_node_id.into_into_dart().into_dart(),
            self.0.short_channel_id.into_into_dart().into_dart(),
            self.0.fees_base_msat.into_into_dart().into_dart(),
            self.0
                .fees_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.0.cltv_expiry_delta.into_into_dart().into_dart(),
            self.0.htlc_minimum_msat.into_into_dart().into_dart(),
            self.0.htlc_maximum_msat.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt11RouteHintHop>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt11RouteHintHop>>
    for crate::models::Bolt11RouteHintHop
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt11RouteHintHop> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.invoice.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12Invoice>>
    for crate::models::Bolt12Invoice
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12InvoiceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_msat.into_into_dart().into_dart(),
            self.0.invoice.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12InvoiceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12InvoiceDetails>>
    for crate::models::Bolt12InvoiceDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12InvoiceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12InvoiceRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12InvoiceRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12InvoiceRequestDetails>>
    for crate::models::Bolt12InvoiceRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12InvoiceRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12Offer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.offer.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12Offer>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12Offer>>
    for crate::models::Bolt12Offer
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12Offer> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12OfferBlindedPath> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.blinded_hops.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12OfferBlindedPath>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12OfferBlindedPath>>
    for crate::models::Bolt12OfferBlindedPath
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12OfferBlindedPath> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Bolt12OfferDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.absolute_expiry.into_into_dart().into_dart(),
            self.0.chains.into_into_dart().into_dart(),
            self.0.description.into_into_dart().into_dart(),
            self.0.issuer.into_into_dart().into_dart(),
            self.0.min_amount.into_into_dart().into_dart(),
            self.0.offer.into_into_dart().into_dart(),
            self.0.paths.into_into_dart().into_dart(),
            self.0.signing_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Bolt12OfferDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Bolt12OfferDetails>>
    for crate::models::Bolt12OfferDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Bolt12OfferDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::BurnIssuerTokenRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.amount.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::BurnIssuerTokenRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::BurnIssuerTokenRequest>>
    for crate::models::BurnIssuerTokenRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::BurnIssuerTokenRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ChainApiType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::ChainApiType::Esplora => 0.into_dart(),
            crate::models::ChainApiType::MempoolSpace => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ChainApiType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ChainApiType>>
    for crate::models::ChainApiType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ChainApiType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::CheckLightningAddressRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.username.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::CheckLightningAddressRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::CheckLightningAddressRequest>>
    for crate::models::CheckLightningAddressRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::CheckLightningAddressRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::CheckMessageRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.message.into_into_dart().into_dart(),
            self.0.pubkey.into_into_dart().into_dart(),
            self.0.signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::CheckMessageRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::CheckMessageRequest>>
    for crate::models::CheckMessageRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::CheckMessageRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::CheckMessageResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.is_valid.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::CheckMessageResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::CheckMessageResponse>>
    for crate::models::CheckMessageResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::CheckMessageResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ClaimDepositRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
            self.0.max_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ClaimDepositRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ClaimDepositRequest>>
    for crate::models::ClaimDepositRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ClaimDepositRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ClaimDepositResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ClaimDepositResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ClaimDepositResponse>>
    for crate::models::ClaimDepositResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ClaimDepositResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ClaimHtlcPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.preimage.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ClaimHtlcPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ClaimHtlcPaymentRequest>>
    for crate::models::ClaimHtlcPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ClaimHtlcPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ClaimHtlcPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ClaimHtlcPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ClaimHtlcPaymentResponse>>
    for crate::models::ClaimHtlcPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ClaimHtlcPaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Config> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.api_key.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.sync_interval_secs.into_into_dart().into_dart(),
            self.0.max_deposit_claim_fee.into_into_dart().into_dart(),
            self.0.lnurl_domain.into_into_dart().into_dart(),
            self.0
                .prefer_spark_over_lightning
                .into_into_dart()
                .into_dart(),
            self.0.external_input_parsers.into_into_dart().into_dart(),
            self.0
                .use_default_external_input_parsers
                .into_into_dart()
                .into_dart(),
            self.0
                .real_time_sync_server_url
                .into_into_dart()
                .into_dart(),
            self.0.private_enabled_default.into_into_dart().into_dart(),
            self.0.optimization_config.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Config>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Config>>
    for crate::models::Config
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Config> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConnectRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.config.into_into_dart().into_dart(),
            self.0.seed.into_into_dart().into_dart(),
            self.0.storage_dir.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConnectRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConnectRequest>>
    for crate::models::ConnectRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConnectRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConversionEstimate> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.options.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConversionEstimate>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConversionEstimate>>
    for crate::models::ConversionEstimate
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConversionEstimate> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConversionInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.pool_id.into_into_dart().into_dart(),
            self.0.conversion_id.into_into_dart().into_dart(),
            self.0.status.into_into_dart().into_dart(),
            self.0.fee.into_into_dart().into_dart(),
            self.0.purpose.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConversionInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConversionInfo>>
    for crate::models::ConversionInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConversionInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConversionOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.conversion_type.into_into_dart().into_dart(),
            self.0.max_slippage_bps.into_into_dart().into_dart(),
            self.0.completion_timeout_secs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConversionOptions>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConversionOptions>>
    for crate::models::ConversionOptions
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConversionOptions> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConversionPurpose> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::ConversionPurpose::OngoingPayment { payment_request } => {
                [0.into_dart(), payment_request.into_into_dart().into_dart()].into_dart()
            }
            crate::models::ConversionPurpose::SelfTransfer => [1.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConversionPurpose>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConversionPurpose>>
    for crate::models::ConversionPurpose
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConversionPurpose> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConversionStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::ConversionStatus::Completed => 0.into_dart(),
            crate::models::ConversionStatus::RefundNeeded => 1.into_dart(),
            crate::models::ConversionStatus::Refunded => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConversionStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConversionStatus>>
    for crate::models::ConversionStatus
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConversionStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ConversionType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::ConversionType::FromBitcoin => [0.into_dart()].into_dart(),
            crate::models::ConversionType::ToBitcoin {
                from_token_identifier,
            } => [
                1.into_dart(),
                from_token_identifier.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ConversionType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ConversionType>>
    for crate::models::ConversionType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ConversionType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::CreateIssuerTokenRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.ticker.into_into_dart().into_dart(),
            self.0.decimals.into_into_dart().into_dart(),
            self.0.is_freezable.into_into_dart().into_dart(),
            self.0.max_supply.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::CreateIssuerTokenRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::CreateIssuerTokenRequest>>
    for crate::models::CreateIssuerTokenRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::CreateIssuerTokenRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Credentials> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.username.into_into_dart().into_dart(),
            self.0.password.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Credentials>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Credentials>>
    for crate::models::Credentials
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Credentials> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::CurrencyInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.fraction_size.into_into_dart().into_dart(),
            self.0.spacing.into_into_dart().into_dart(),
            self.0.symbol.into_into_dart().into_dart(),
            self.0.uniq_symbol.into_into_dart().into_dart(),
            self.0.localized_name.into_into_dart().into_dart(),
            self.0.locale_overrides.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::CurrencyInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::CurrencyInfo>>
    for crate::models::CurrencyInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::CurrencyInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::errors::DepositClaimError> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::errors::DepositClaimError::MaxDepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                required_fee_sats,
                required_fee_rate_sat_per_vbyte,
            } => [
                0.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
                max_fee.into_into_dart().into_dart(),
                required_fee_sats.into_into_dart().into_dart(),
                required_fee_rate_sat_per_vbyte.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::DepositClaimError::MissingUtxo { tx, vout } => [
                1.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::DepositClaimError::Generic { message } => {
                [2.into_dart(), message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::errors::DepositClaimError>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::errors::DepositClaimError>>
    for crate::errors::DepositClaimError
{
    fn into_into_dart(self) -> FrbWrapper<crate::errors::DepositClaimError> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::DepositInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
            self.0.amount_sats.into_into_dart().into_dart(),
            self.0.refund_tx.into_into_dart().into_dart(),
            self.0.refund_tx_id.into_into_dart().into_dart(),
            self.0.claim_error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::DepositInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::DepositInfo>>
    for crate::models::DepositInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::DepositInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ExternalInputParser> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.provider_id.into_into_dart().into_dart(),
            self.0.input_regex.into_into_dart().into_dart(),
            self.0.parser_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ExternalInputParser>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ExternalInputParser>>
    for crate::models::ExternalInputParser
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ExternalInputParser> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Fee> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Fee::Fixed { amount } => {
                [0.into_dart(), amount.into_into_dart().into_dart()].into_dart()
            }
            crate::models::Fee::Rate { sat_per_vbyte } => {
                [1.into_dart(), sat_per_vbyte.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Fee>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Fee>> for crate::models::Fee {
    fn into_into_dart(self) -> FrbWrapper<crate::models::Fee> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::FetchConversionLimitsRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.conversion_type.into_into_dart().into_dart(),
            self.0.token_identifier.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::FetchConversionLimitsRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::FetchConversionLimitsRequest>>
    for crate::models::FetchConversionLimitsRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::FetchConversionLimitsRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::FetchConversionLimitsResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.min_from_amount.into_into_dart().into_dart(),
            self.0.min_to_amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::FetchConversionLimitsResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::FetchConversionLimitsResponse>>
    for crate::models::FetchConversionLimitsResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::FetchConversionLimitsResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::FiatCurrency> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::FiatCurrency>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::FiatCurrency>>
    for crate::models::FiatCurrency
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::FiatCurrency> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::FreezeIssuerTokenRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.address.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::FreezeIssuerTokenRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::FreezeIssuerTokenRequest>>
    for crate::models::FreezeIssuerTokenRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::FreezeIssuerTokenRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::FreezeIssuerTokenResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.impacted_output_ids.into_into_dart().into_dart(),
            self.0.impacted_token_amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::FreezeIssuerTokenResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::FreezeIssuerTokenResponse>>
    for crate::models::FreezeIssuerTokenResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::FreezeIssuerTokenResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetInfoRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.ensure_synced.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetInfoRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetInfoRequest>>
    for crate::models::GetInfoRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetInfoRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetInfoResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.balance_sats.into_into_dart().into_dart(),
            self.0.token_balances.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetInfoResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetInfoResponse>>
    for crate::models::GetInfoResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetInfoResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment_id.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetPaymentRequest>>
    for crate::models::GetPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetPaymentResponse>>
    for crate::models::GetPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetPaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetTokensMetadataRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.token_identifiers.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetTokensMetadataRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetTokensMetadataRequest>>
    for crate::models::GetTokensMetadataRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetTokensMetadataRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::GetTokensMetadataResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.tokens_metadata.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::GetTokensMetadataResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::GetTokensMetadataResponse>>
    for crate::models::GetTokensMetadataResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::GetTokensMetadataResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::InputType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::InputType::BitcoinAddress(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt11Invoice(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt12Invoice(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt12Offer(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LightningAddress(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LnurlPay(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::SilentPaymentAddress(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LnurlAuth(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Url(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bip21(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::Bolt12InvoiceRequest(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::LnurlWithdraw(field0) => {
                [11.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::SparkAddress(field0) => {
                [12.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::models::InputType::SparkInvoice(field0) => {
                [13.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::InputType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::InputType>>
    for crate::models::InputType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::InputType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::KeySetConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.key_set_type.into_into_dart().into_dart(),
            self.0.use_address_index.into_into_dart().into_dart(),
            self.0.account_number.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::KeySetConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::KeySetConfig>>
    for crate::models::KeySetConfig
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::KeySetConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::KeySetType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::KeySetType::Default => 0.into_dart(),
            crate::models::KeySetType::Taproot => 1.into_dart(),
            crate::models::KeySetType::NativeSegwit => 2.into_dart(),
            crate::models::KeySetType::WrappedSegwit => 3.into_dart(),
            crate::models::KeySetType::Legacy => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::KeySetType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::KeySetType>>
    for crate::models::KeySetType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::KeySetType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LightningAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.pay_request.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LightningAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LightningAddressDetails>>
    for crate::models::LightningAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LightningAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LightningAddressInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.lightning_address.into_into_dart().into_dart(),
            self.0.lnurl.into_into_dart().into_dart(),
            self.0.username.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LightningAddressInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LightningAddressInfo>>
    for crate::models::LightningAddressInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LightningAddressInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListFiatCurrenciesResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.currencies.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListFiatCurrenciesResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListFiatCurrenciesResponse>>
    for crate::models::ListFiatCurrenciesResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListFiatCurrenciesResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListFiatRatesResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.rates.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListFiatRatesResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListFiatRatesResponse>>
    for crate::models::ListFiatRatesResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListFiatRatesResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListPaymentsRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.type_filter.into_into_dart().into_dart(),
            self.0.status_filter.into_into_dart().into_dart(),
            self.0.asset_filter.into_into_dart().into_dart(),
            self.0.payment_details_filter.into_into_dart().into_dart(),
            self.0.from_timestamp.into_into_dart().into_dart(),
            self.0.to_timestamp.into_into_dart().into_dart(),
            self.0.offset.into_into_dart().into_dart(),
            self.0.limit.into_into_dart().into_dart(),
            self.0.sort_ascending.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListPaymentsRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListPaymentsRequest>>
    for crate::models::ListPaymentsRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListPaymentsRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListPaymentsResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payments.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListPaymentsResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListPaymentsResponse>>
    for crate::models::ListPaymentsResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListPaymentsResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListUnclaimedDepositsRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListUnclaimedDepositsRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListUnclaimedDepositsRequest>>
    for crate::models::ListUnclaimedDepositsRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListUnclaimedDepositsRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ListUnclaimedDepositsResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.deposits.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ListUnclaimedDepositsResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ListUnclaimedDepositsResponse>>
    for crate::models::ListUnclaimedDepositsResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ListUnclaimedDepositsResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlAuthRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.k1.into_into_dart().into_dart(),
            self.0.action.into_into_dart().into_dart(),
            self.0.domain.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlAuthRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlAuthRequestDetails>>
    for crate::models::LnurlAuthRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlAuthRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlCallbackStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::LnurlCallbackStatus::Ok => [0.into_dart()].into_dart(),
            crate::models::LnurlCallbackStatus::ErrorStatus { error_details } => {
                [1.into_dart(), error_details.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlCallbackStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlCallbackStatus>>
    for crate::models::LnurlCallbackStatus
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlCallbackStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlErrorDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.reason.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlErrorDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlErrorDetails>>
    for crate::models::LnurlErrorDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlErrorDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ln_address.into_into_dart().into_dart(),
            self.0.comment.into_into_dart().into_dart(),
            self.0.domain.into_into_dart().into_dart(),
            self.0.metadata.into_into_dart().into_dart(),
            self.0.processed_success_action.into_into_dart().into_dart(),
            self.0.raw_success_action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayInfo>>
    for crate::models::LnurlPayInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.prepare_response.into_into_dart().into_dart(),
            self.0.idempotency_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayRequest>>
    for crate::models::LnurlPayRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.callback.into_into_dart().into_dart(),
            self.0.min_sendable.into_into_dart().into_dart(),
            self.0.max_sendable.into_into_dart().into_dart(),
            self.0.metadata_str.into_into_dart().into_dart(),
            self.0.comment_allowed.into_into_dart().into_dart(),
            self.0.domain.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
            self.0.address.into_into_dart().into_dart(),
            self.0.allows_nostr.into_into_dart().into_dart(),
            self.0.nostr_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayRequestDetails>>
    for crate::models::LnurlPayRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlPayResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment.into_into_dart().into_dart(),
            self.0.success_action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlPayResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlPayResponse>>
    for crate::models::LnurlPayResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlPayResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlReceiveMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.nostr_zap_request.into_into_dart().into_dart(),
            self.0.nostr_zap_receipt.into_into_dart().into_dart(),
            self.0.sender_comment.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlReceiveMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlReceiveMetadata>>
    for crate::models::LnurlReceiveMetadata
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlReceiveMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlWithdrawInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.withdraw_url.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlWithdrawInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlWithdrawInfo>>
    for crate::models::LnurlWithdrawInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlWithdrawInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlWithdrawRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_sats.into_into_dart().into_dart(),
            self.0.withdraw_request.into_into_dart().into_dart(),
            self.0.completion_timeout_secs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlWithdrawRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlWithdrawRequest>>
    for crate::models::LnurlWithdrawRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlWithdrawRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlWithdrawRequestDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.callback.into_into_dart().into_dart(),
            self.0.k1.into_into_dart().into_dart(),
            self.0.default_description.into_into_dart().into_dart(),
            self.0.min_withdrawable.into_into_dart().into_dart(),
            self.0.max_withdrawable.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlWithdrawRequestDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlWithdrawRequestDetails>>
    for crate::models::LnurlWithdrawRequestDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlWithdrawRequestDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LnurlWithdrawResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_request.into_into_dart().into_dart(),
            self.0.payment.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LnurlWithdrawResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LnurlWithdrawResponse>>
    for crate::models::LnurlWithdrawResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LnurlWithdrawResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LocaleOverrides> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.locale.into_into_dart().into_dart(),
            self.0.spacing.into_into_dart().into_dart(),
            self.0.symbol.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LocaleOverrides>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LocaleOverrides>>
    for crate::models::LocaleOverrides
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LocaleOverrides> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::LocalizedName> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.locale.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::LocalizedName>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::LocalizedName>>
    for crate::models::LocalizedName
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::LocalizedName> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::logger::LogEntry> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.line.into_into_dart().into_dart(),
            self.0.level.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::logger::LogEntry>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::logger::LogEntry>>
    for crate::logger::LogEntry
{
    fn into_into_dart(self) -> FrbWrapper<crate::logger::LogEntry> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::MaxFee> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::MaxFee::Fixed { amount } => {
                [0.into_dart(), amount.into_into_dart().into_dart()].into_dart()
            }
            crate::models::MaxFee::Rate { sat_per_vbyte } => {
                [1.into_dart(), sat_per_vbyte.into_into_dart().into_dart()].into_dart()
            }
            crate::models::MaxFee::NetworkRecommended {
                leeway_sat_per_vbyte,
            } => [
                2.into_dart(),
                leeway_sat_per_vbyte.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::MaxFee>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::MaxFee>>
    for crate::models::MaxFee
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::MaxFee> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::MessageSuccessActionData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.message.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::MessageSuccessActionData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::MessageSuccessActionData>>
    for crate::models::MessageSuccessActionData
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::MessageSuccessActionData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::MintIssuerTokenRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.amount.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::MintIssuerTokenRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::MintIssuerTokenRequest>>
    for crate::models::MintIssuerTokenRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::MintIssuerTokenRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Network> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Network::Mainnet => 0.into_dart(),
            crate::models::Network::Regtest => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Network>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Network>>
    for crate::models::Network
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Network> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::OnchainConfirmationSpeed> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::OnchainConfirmationSpeed::Fast => 0.into_dart(),
            crate::models::OnchainConfirmationSpeed::Medium => 1.into_dart(),
            crate::models::OnchainConfirmationSpeed::Slow => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::OnchainConfirmationSpeed>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::OnchainConfirmationSpeed>>
    for crate::models::OnchainConfirmationSpeed
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::OnchainConfirmationSpeed> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::OptimizationConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.auto_enabled.into_into_dart().into_dart(),
            self.0.multiplicity.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::OptimizationConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::OptimizationConfig>>
    for crate::models::OptimizationConfig
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::OptimizationConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::events::OptimizationEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::events::OptimizationEvent::Started { total_rounds } => {
                [0.into_dart(), total_rounds.into_into_dart().into_dart()].into_dart()
            }
            crate::events::OptimizationEvent::RoundCompleted {
                current_round,
                total_rounds,
            } => [
                1.into_dart(),
                current_round.into_into_dart().into_dart(),
                total_rounds.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::events::OptimizationEvent::Completed => [2.into_dart()].into_dart(),
            crate::events::OptimizationEvent::Cancelled => [3.into_dart()].into_dart(),
            crate::events::OptimizationEvent::Failed { error } => {
                [4.into_dart(), error.into_into_dart().into_dart()].into_dart()
            }
            crate::events::OptimizationEvent::Skipped => [5.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::events::OptimizationEvent>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::events::OptimizationEvent>>
    for crate::events::OptimizationEvent
{
    fn into_into_dart(self) -> FrbWrapper<crate::events::OptimizationEvent> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::OptimizationProgress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.is_running.into_into_dart().into_dart(),
            self.0.current_round.into_into_dart().into_dart(),
            self.0.total_rounds.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::OptimizationProgress>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::OptimizationProgress>>
    for crate::models::OptimizationProgress
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::OptimizationProgress> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.payment_type.into_into_dart().into_dart(),
            self.0.status.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.fees.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
            self.0.method.into_into_dart().into_dart(),
            self.0.details.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Payment>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Payment>>
    for crate::models::Payment
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Payment> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentDetails::Spark {
                invoice_details,
                htlc_details,
                conversion_info,
            } => [
                0.into_dart(),
                invoice_details.into_into_dart().into_dart(),
                htlc_details.into_into_dart().into_dart(),
                conversion_info.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::PaymentDetails::Token {
                metadata,
                tx_hash,
                invoice_details,
                conversion_info,
            } => [
                1.into_dart(),
                metadata.into_into_dart().into_dart(),
                tx_hash.into_into_dart().into_dart(),
                invoice_details.into_into_dart().into_dart(),
                conversion_info.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::PaymentDetails::Lightning {
                description,
                preimage,
                invoice,
                payment_hash,
                destination_pubkey,
                lnurl_pay_info,
                lnurl_withdraw_info,
                lnurl_receive_metadata,
            } => [
                2.into_dart(),
                description.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                invoice.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                destination_pubkey.into_into_dart().into_dart(),
                lnurl_pay_info.into_into_dart().into_dart(),
                lnurl_withdraw_info.into_into_dart().into_dart(),
                lnurl_receive_metadata.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::PaymentDetails::Withdraw { tx_id } => {
                [3.into_dart(), tx_id.into_into_dart().into_dart()].into_dart()
            }
            crate::models::PaymentDetails::Deposit { tx_id } => {
                [4.into_dart(), tx_id.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentDetails>>
    for crate::models::PaymentDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentDetailsFilter> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentDetailsFilter::Spark {
                htlc_status,
                conversion_refund_needed,
            } => [
                0.into_dart(),
                htlc_status.into_into_dart().into_dart(),
                conversion_refund_needed.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::PaymentDetailsFilter::Token {
                conversion_refund_needed,
                tx_hash,
            } => [
                1.into_dart(),
                conversion_refund_needed.into_into_dart().into_dart(),
                tx_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentDetailsFilter>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentDetailsFilter>>
    for crate::models::PaymentDetailsFilter
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentDetailsFilter> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentMethod> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentMethod::Lightning => 0.into_dart(),
            crate::models::PaymentMethod::Spark => 1.into_dart(),
            crate::models::PaymentMethod::Token => 2.into_dart(),
            crate::models::PaymentMethod::Deposit => 3.into_dart(),
            crate::models::PaymentMethod::Withdraw => 4.into_dart(),
            crate::models::PaymentMethod::Unknown => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentMethod>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentMethod>>
    for crate::models::PaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentRequestSource> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.bip_21_uri.into_into_dart().into_dart(),
            self.0.bip_353_address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentRequestSource>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentRequestSource>>
    for crate::models::PaymentRequestSource
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentRequestSource> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentStatus::Completed => 0.into_dart(),
            crate::models::PaymentStatus::Pending => 1.into_dart(),
            crate::models::PaymentStatus::Failed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentStatus>>
    for crate::models::PaymentStatus
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PaymentType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::PaymentType::Send => 0.into_dart(),
            crate::models::PaymentType::Receive => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PaymentType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PaymentType>>
    for crate::models::PaymentType
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PaymentType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareLnurlPayRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_sats.into_into_dart().into_dart(),
            self.0.pay_request.into_into_dart().into_dart(),
            self.0.comment.into_into_dart().into_dart(),
            self.0
                .validate_success_action_url
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareLnurlPayRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareLnurlPayRequest>>
    for crate::models::PrepareLnurlPayRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareLnurlPayRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareLnurlPayResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.amount_sats.into_into_dart().into_dart(),
            self.0.comment.into_into_dart().into_dart(),
            self.0.pay_request.into_into_dart().into_dart(),
            self.0.fee_sats.into_into_dart().into_dart(),
            self.0.invoice_details.into_into_dart().into_dart(),
            self.0.success_action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareLnurlPayResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareLnurlPayResponse>>
    for crate::models::PrepareLnurlPayResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareLnurlPayResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareSendPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_request.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.token_identifier.into_into_dart().into_dart(),
            self.0.conversion_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareSendPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareSendPaymentRequest>>
    for crate::models::PrepareSendPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareSendPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::PrepareSendPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_method.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.token_identifier.into_into_dart().into_dart(),
            self.0.conversion_estimate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::PrepareSendPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::PrepareSendPaymentResponse>>
    for crate::models::PrepareSendPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::PrepareSendPaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Rate> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.coin.into_into_dart().into_dart(),
            self.0.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Rate>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Rate>> for crate::models::Rate {
    fn into_into_dart(self) -> FrbWrapper<crate::models::Rate> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ReceivePaymentMethod> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::ReceivePaymentMethod::SparkAddress => [0.into_dart()].into_dart(),
            crate::models::ReceivePaymentMethod::SparkInvoice {
                amount,
                token_identifier,
                expiry_time,
                description,
                sender_public_key,
            } => [
                1.into_dart(),
                amount.into_into_dart().into_dart(),
                token_identifier.into_into_dart().into_dart(),
                expiry_time.into_into_dart().into_dart(),
                description.into_into_dart().into_dart(),
                sender_public_key.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::ReceivePaymentMethod::BitcoinAddress => [2.into_dart()].into_dart(),
            crate::models::ReceivePaymentMethod::Bolt11Invoice {
                description,
                amount_sats,
                expiry_secs,
            } => [
                3.into_dart(),
                description.into_into_dart().into_dart(),
                amount_sats.into_into_dart().into_dart(),
                expiry_secs.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ReceivePaymentMethod>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ReceivePaymentMethod>>
    for crate::models::ReceivePaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ReceivePaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ReceivePaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment_method.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ReceivePaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ReceivePaymentRequest>>
    for crate::models::ReceivePaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ReceivePaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::ReceivePaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_request.into_into_dart().into_dart(),
            self.0.fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::ReceivePaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::ReceivePaymentResponse>>
    for crate::models::ReceivePaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::ReceivePaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::RecommendedFees> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.fastest_fee.into_into_dart().into_dart(),
            self.0.half_hour_fee.into_into_dart().into_dart(),
            self.0.hour_fee.into_into_dart().into_dart(),
            self.0.economy_fee.into_into_dart().into_dart(),
            self.0.minimum_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::RecommendedFees>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::RecommendedFees>>
    for crate::models::RecommendedFees
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::RecommendedFees> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::RefundDepositRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
            self.0.destination_address.into_into_dart().into_dart(),
            self.0.fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::RefundDepositRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::RefundDepositRequest>>
    for crate::models::RefundDepositRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::RefundDepositRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::RefundDepositResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.tx_id.into_into_dart().into_dart(),
            self.0.tx_hex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::RefundDepositResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::RefundDepositResponse>>
    for crate::models::RefundDepositResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::RefundDepositResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::RegisterLightningAddressRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.username.into_into_dart().into_dart(),
            self.0.description.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::RegisterLightningAddressRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::RegisterLightningAddressRequest>>
    for crate::models::RegisterLightningAddressRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::RegisterLightningAddressRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::errors::SdkError> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::errors::SdkError::SparkError(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::InsufficientFunds => [1.into_dart()].into_dart(),
            crate::errors::SdkError::InvalidUuid(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::InvalidInput(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::NetworkError(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::StorageError(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::ChainServiceError(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::MaxDepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                required_fee_sats,
                required_fee_rate_sat_per_vbyte,
            } => [
                7.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
                max_fee.into_into_dart().into_dart(),
                required_fee_sats.into_into_dart().into_dart(),
                required_fee_rate_sat_per_vbyte.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::SdkError::MissingUtxo { tx, vout } => [
                8.into_dart(),
                tx.into_into_dart().into_dart(),
                vout.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::errors::SdkError::LnurlError(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::Signer(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::errors::SdkError::Generic(field0) => {
                [11.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::errors::SdkError>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::errors::SdkError>>
    for crate::errors::SdkError
{
    fn into_into_dart(self) -> FrbWrapper<crate::errors::SdkError> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::events::SdkEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::events::SdkEvent::Synced => [0.into_dart()].into_dart(),
            crate::events::SdkEvent::UnclaimedDeposits { unclaimed_deposits } => [
                1.into_dart(),
                unclaimed_deposits.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::events::SdkEvent::ClaimedDeposits { claimed_deposits } => {
                [2.into_dart(), claimed_deposits.into_into_dart().into_dart()].into_dart()
            }
            crate::events::SdkEvent::PaymentSucceeded { payment } => {
                [3.into_dart(), payment.into_into_dart().into_dart()].into_dart()
            }
            crate::events::SdkEvent::PaymentPending { payment } => {
                [4.into_dart(), payment.into_into_dart().into_dart()].into_dart()
            }
            crate::events::SdkEvent::PaymentFailed { payment } => {
                [5.into_dart(), payment.into_into_dart().into_dart()].into_dart()
            }
            crate::events::SdkEvent::Optimization { optimization_event } => [
                6.into_dart(),
                optimization_event.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::events::SdkEvent>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::events::SdkEvent>>
    for crate::events::SdkEvent
{
    fn into_into_dart(self) -> FrbWrapper<crate::events::SdkEvent> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Seed> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::Seed::Mnemonic {
                mnemonic,
                passphrase,
            } => [
                0.into_dart(),
                mnemonic.into_into_dart().into_dart(),
                passphrase.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::Seed::Entropy(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Seed>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Seed>> for crate::models::Seed {
    fn into_into_dart(self) -> FrbWrapper<crate::models::Seed> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendOnchainFeeQuote> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.expires_at.into_into_dart().into_dart(),
            self.0.speed_fast.into_into_dart().into_dart(),
            self.0.speed_medium.into_into_dart().into_dart(),
            self.0.speed_slow.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendOnchainFeeQuote>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendOnchainFeeQuote>>
    for crate::models::SendOnchainFeeQuote
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendOnchainFeeQuote> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendOnchainSpeedFeeQuote> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.user_fee_sat.into_into_dart().into_dart(),
            self.0.l1_broadcast_fee_sat.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendOnchainSpeedFeeQuote>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendOnchainSpeedFeeQuote>>
    for crate::models::SendOnchainSpeedFeeQuote
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendOnchainSpeedFeeQuote> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentMethod> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SendPaymentMethod::BitcoinAddress { address, fee_quote } => [
                0.into_dart(),
                address.into_into_dart().into_dart(),
                fee_quote.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentMethod::Bolt11Invoice {
                invoice_details,
                spark_transfer_fee_sats,
                lightning_fee_sats,
            } => [
                1.into_dart(),
                invoice_details.into_into_dart().into_dart(),
                spark_transfer_fee_sats.into_into_dart().into_dart(),
                lightning_fee_sats.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentMethod::SparkAddress {
                address,
                fee,
                token_identifier,
            } => [
                2.into_dart(),
                address.into_into_dart().into_dart(),
                fee.into_into_dart().into_dart(),
                token_identifier.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentMethod::SparkInvoice {
                spark_invoice_details,
                fee,
                token_identifier,
            } => [
                3.into_dart(),
                spark_invoice_details.into_into_dart().into_dart(),
                fee.into_into_dart().into_dart(),
                token_identifier.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentMethod>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentMethod>>
    for crate::models::SendPaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SendPaymentOptions::BitcoinAddress { confirmation_speed } => [
                0.into_dart(),
                confirmation_speed.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentOptions::Bolt11Invoice {
                prefer_spark,
                completion_timeout_secs,
            } => [
                1.into_dart(),
                prefer_spark.into_into_dart().into_dart(),
                completion_timeout_secs.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::SendPaymentOptions::SparkAddress { htlc_options } => {
                [2.into_dart(), htlc_options.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentOptions>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentOptions>>
    for crate::models::SendPaymentOptions
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentOptions> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.prepare_response.into_into_dart().into_dart(),
            self.0.options.into_into_dart().into_dart(),
            self.0.idempotency_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentRequest>>
    for crate::models::SendPaymentRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SendPaymentResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payment.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SendPaymentResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SendPaymentResponse>>
    for crate::models::SendPaymentResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SendPaymentResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SignMessageRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.message.into_into_dart().into_dart(),
            self.0.compact.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SignMessageRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SignMessageRequest>>
    for crate::models::SignMessageRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SignMessageRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SignMessageResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.pubkey.into_into_dart().into_dart(),
            self.0.signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SignMessageResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SignMessageResponse>>
    for crate::models::SignMessageResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SignMessageResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SilentPaymentAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SilentPaymentAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SilentPaymentAddressDetails>>
    for crate::models::SilentPaymentAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SilentPaymentAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.address.into_into_dart().into_dart(),
            self.0.identity_public_key.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkAddressDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkAddressDetails>>
    for crate::models::SparkAddressDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkAddressDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkHtlcDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_hash.into_into_dart().into_dart(),
            self.0.preimage.into_into_dart().into_dart(),
            self.0.expiry_time.into_into_dart().into_dart(),
            self.0.status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkHtlcDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkHtlcDetails>>
    for crate::models::SparkHtlcDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkHtlcDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkHtlcOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.payment_hash.into_into_dart().into_dart(),
            self.0.expiry_duration_secs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkHtlcOptions>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkHtlcOptions>>
    for crate::models::SparkHtlcOptions
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkHtlcOptions> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkHtlcStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SparkHtlcStatus::WaitingForPreimage => 0.into_dart(),
            crate::models::SparkHtlcStatus::PreimageShared => 1.into_dart(),
            crate::models::SparkHtlcStatus::Returned => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkHtlcStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkHtlcStatus>>
    for crate::models::SparkHtlcStatus
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkHtlcStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkInvoiceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.invoice.into_into_dart().into_dart(),
            self.0.identity_public_key.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.amount.into_into_dart().into_dart(),
            self.0.token_identifier.into_into_dart().into_dart(),
            self.0.expiry_time.into_into_dart().into_dart(),
            self.0.description.into_into_dart().into_dart(),
            self.0.sender_public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkInvoiceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkInvoiceDetails>>
    for crate::models::SparkInvoiceDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkInvoiceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SparkInvoicePaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.invoice.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SparkInvoicePaymentDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SparkInvoicePaymentDetails>>
    for crate::models::SparkInvoicePaymentDetails
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SparkInvoicePaymentDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SuccessAction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SuccessAction::Aes { data } => {
                [0.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessAction::Message { data } => {
                [1.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessAction::Url { data } => {
                [2.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SuccessAction>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SuccessAction>>
    for crate::models::SuccessAction
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SuccessAction> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SuccessActionProcessed> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::models::SuccessActionProcessed::Aes { result } => {
                [0.into_dart(), result.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessActionProcessed::Message { data } => {
                [1.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::models::SuccessActionProcessed::Url { data } => {
                [2.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SuccessActionProcessed>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SuccessActionProcessed>>
    for crate::models::SuccessActionProcessed
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SuccessActionProcessed> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::Symbol> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.grapheme.into_into_dart().into_dart(),
            self.0.template.into_into_dart().into_dart(),
            self.0.rtl.into_into_dart().into_dart(),
            self.0.position.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::Symbol>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::Symbol>>
    for crate::models::Symbol
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::Symbol> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SyncWalletRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SyncWalletRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SyncWalletRequest>>
    for crate::models::SyncWalletRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SyncWalletRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::SyncWalletResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::SyncWalletResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::SyncWalletResponse>>
    for crate::models::SyncWalletResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::SyncWalletResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::TokenBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.balance.into_into_dart().into_dart(),
            self.0.token_metadata.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::TokenBalance>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::TokenBalance>>
    for crate::models::TokenBalance
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::TokenBalance> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::TokenMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.identifier.into_into_dart().into_dart(),
            self.0.issuer_public_key.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
            self.0.ticker.into_into_dart().into_dart(),
            self.0.decimals.into_into_dart().into_dart(),
            self.0.max_supply.into_into_dart().into_dart(),
            self.0.is_freezable.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::TokenMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::TokenMetadata>>
    for crate::models::TokenMetadata
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::TokenMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::UnfreezeIssuerTokenRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.address.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::UnfreezeIssuerTokenRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::UnfreezeIssuerTokenRequest>>
    for crate::models::UnfreezeIssuerTokenRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::UnfreezeIssuerTokenRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::UnfreezeIssuerTokenResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.impacted_output_ids.into_into_dart().into_dart(),
            self.0.impacted_token_amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::UnfreezeIssuerTokenResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::UnfreezeIssuerTokenResponse>>
    for crate::models::UnfreezeIssuerTokenResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::UnfreezeIssuerTokenResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::UpdateUserSettingsRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self
            .0
            .spark_private_mode_enabled
            .into_into_dart()
            .into_dart()]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::UpdateUserSettingsRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::UpdateUserSettingsRequest>>
    for crate::models::UpdateUserSettingsRequest
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::UpdateUserSettingsRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::UrlSuccessActionData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.description.into_into_dart().into_dart(),
            self.0.url.into_into_dart().into_dart(),
            self.0.matches_callback_domain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::UrlSuccessActionData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::UrlSuccessActionData>>
    for crate::models::UrlSuccessActionData
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::UrlSuccessActionData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::models::UserSettings> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self
            .0
            .spark_private_mode_enabled
            .into_into_dart()
            .into_dart()]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::models::UserSettings>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::models::UserSettings>>
    for crate::models::UserSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::models::UserSettings> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for BreezSdk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for SdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for TokenIssuer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< TokenIssuer>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, crate::models::TokenBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::models::TokenBalance)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TokenIssuer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for StreamSink<crate::logger::LogEntry, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::events::SdkEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_string(), serializer);
    }
}

impl SseEncode for crate::models::AesSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.ciphertext, serializer);
        <String>::sse_encode(self.iv, serializer);
    }
}

impl SseEncode for crate::models::AesSuccessActionDataDecrypted {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.plaintext, serializer);
    }
}

impl SseEncode for crate::models::AesSuccessActionDataResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::AesSuccessActionDataResult::Decrypted { data } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::AesSuccessActionDataDecrypted>::sse_encode(data, serializer);
            }
            crate::models::AesSuccessActionDataResult::ErrorStatus { reason } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(reason, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Amount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::Amount::Bitcoin { amount_msat } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(amount_msat, serializer);
            }
            crate::models::Amount::Currency {
                iso4217_code,
                fractional_amount,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(iso4217_code, serializer);
                <u64>::sse_encode(fractional_amount, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::AssetFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::AssetFilter::Bitcoin => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::AssetFilter::Token { token_identifier } => {
                <i32>::sse_encode(1, serializer);
                <Option<String>>::sse_encode(token_identifier, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Bip21Details {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.amount_sat, serializer);
        <Option<String>>::sse_encode(self.asset_id, serializer);
        <String>::sse_encode(self.uri, serializer);
        <Vec<crate::models::Bip21Extra>>::sse_encode(self.extras, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <Option<String>>::sse_encode(self.message, serializer);
        <Vec<crate::models::InputType>>::sse_encode(self.payment_methods, serializer);
    }
}

impl SseEncode for crate::models::Bip21Extra {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.key, serializer);
        <String>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::BitcoinAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::BitcoinNetwork {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::BitcoinNetwork::Bitcoin => 0,
                crate::models::BitcoinNetwork::Testnet3 => 1,
                crate::models::BitcoinNetwork::Testnet4 => 2,
                crate::models::BitcoinNetwork::Signet => 3,
                crate::models::BitcoinNetwork::Regtest => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.bolt11, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::Bolt11InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.amount_msat, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<String>>::sse_encode(self.description_hash, serializer);
        <u64>::sse_encode(self.expiry, serializer);
        <crate::models::Bolt11Invoice>::sse_encode(self.invoice, serializer);
        <u64>::sse_encode(self.min_final_cltv_expiry_delta, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <String>::sse_encode(self.payee_pubkey, serializer);
        <String>::sse_encode(self.payment_hash, serializer);
        <String>::sse_encode(self.payment_secret, serializer);
        <Vec<crate::models::Bolt11RouteHint>>::sse_encode(self.routing_hints, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for crate::models::Bolt11RouteHint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::Bolt11RouteHintHop>>::sse_encode(self.hops, serializer);
    }
}

impl SseEncode for crate::models::Bolt11RouteHintHop {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.src_node_id, serializer);
        <String>::sse_encode(self.short_channel_id, serializer);
        <u32>::sse_encode(self.fees_base_msat, serializer);
        <u32>::sse_encode(self.fees_proportional_millionths, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <Option<u64>>::sse_encode(self.htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.htlc_maximum_msat, serializer);
    }
}

impl SseEncode for crate::models::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.invoice, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::Bolt12InvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.amount_msat, serializer);
        <crate::models::Bolt12Invoice>::sse_encode(self.invoice, serializer);
    }
}

impl SseEncode for crate::models::Bolt12InvoiceRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::Bolt12Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.offer, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::Bolt12OfferBlindedPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.blinded_hops, serializer);
    }
}

impl SseEncode for crate::models::Bolt12OfferDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.absolute_expiry, serializer);
        <Vec<String>>::sse_encode(self.chains, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<String>>::sse_encode(self.issuer, serializer);
        <Option<crate::models::Amount>>::sse_encode(self.min_amount, serializer);
        <crate::models::Bolt12Offer>::sse_encode(self.offer, serializer);
        <Vec<crate::models::Bolt12OfferBlindedPath>>::sse_encode(self.paths, serializer);
        <Option<String>>::sse_encode(self.signing_pubkey, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::BurnIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::models::ChainApiType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::ChainApiType::Esplora => 0,
                crate::models::ChainApiType::MempoolSpace => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::CheckLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
    }
}

impl SseEncode for crate::models::CheckMessageRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
        <String>::sse_encode(self.pubkey, serializer);
        <String>::sse_encode(self.signature, serializer);
    }
}

impl SseEncode for crate::models::CheckMessageResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_valid, serializer);
    }
}

impl SseEncode for crate::models::ClaimDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
        <Option<crate::models::MaxFee>>::sse_encode(self.max_fee, serializer);
    }
}

impl SseEncode for crate::models::ClaimDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::ClaimHtlcPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.preimage, serializer);
    }
}

impl SseEncode for crate::models::ClaimHtlcPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.api_key, serializer);
        <crate::models::Network>::sse_encode(self.network, serializer);
        <u32>::sse_encode(self.sync_interval_secs, serializer);
        <Option<crate::models::MaxFee>>::sse_encode(self.max_deposit_claim_fee, serializer);
        <Option<String>>::sse_encode(self.lnurl_domain, serializer);
        <bool>::sse_encode(self.prefer_spark_over_lightning, serializer);
        <Option<Vec<crate::models::ExternalInputParser>>>::sse_encode(
            self.external_input_parsers,
            serializer,
        );
        <bool>::sse_encode(self.use_default_external_input_parsers, serializer);
        <Option<String>>::sse_encode(self.real_time_sync_server_url, serializer);
        <bool>::sse_encode(self.private_enabled_default, serializer);
        <crate::models::OptimizationConfig>::sse_encode(self.optimization_config, serializer);
    }
}

impl SseEncode for crate::models::ConnectRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Config>::sse_encode(self.config, serializer);
        <crate::models::Seed>::sse_encode(self.seed, serializer);
        <String>::sse_encode(self.storage_dir, serializer);
    }
}

impl SseEncode for crate::models::ConversionEstimate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::ConversionOptions>::sse_encode(self.options, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <u128>::sse_encode(self.fee, serializer);
    }
}

impl SseEncode for crate::models::ConversionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.pool_id, serializer);
        <String>::sse_encode(self.conversion_id, serializer);
        <crate::models::ConversionStatus>::sse_encode(self.status, serializer);
        <Option<u128>>::sse_encode(self.fee, serializer);
        <Option<crate::models::ConversionPurpose>>::sse_encode(self.purpose, serializer);
    }
}

impl SseEncode for crate::models::ConversionOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::ConversionType>::sse_encode(self.conversion_type, serializer);
        <Option<u32>>::sse_encode(self.max_slippage_bps, serializer);
        <Option<u32>>::sse_encode(self.completion_timeout_secs, serializer);
    }
}

impl SseEncode for crate::models::ConversionPurpose {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::ConversionPurpose::OngoingPayment { payment_request } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(payment_request, serializer);
            }
            crate::models::ConversionPurpose::SelfTransfer => {
                <i32>::sse_encode(1, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::ConversionStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::ConversionStatus::Completed => 0,
                crate::models::ConversionStatus::RefundNeeded => 1,
                crate::models::ConversionStatus::Refunded => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::ConversionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::ConversionType::FromBitcoin => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::ConversionType::ToBitcoin {
                from_token_identifier,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(from_token_identifier, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::CreateIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.ticker, serializer);
        <u32>::sse_encode(self.decimals, serializer);
        <bool>::sse_encode(self.is_freezable, serializer);
        <u128>::sse_encode(self.max_supply, serializer);
    }
}

impl SseEncode for crate::models::Credentials {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.password, serializer);
    }
}

impl SseEncode for crate::models::CurrencyInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <u32>::sse_encode(self.fraction_size, serializer);
        <Option<u32>>::sse_encode(self.spacing, serializer);
        <Option<crate::models::Symbol>>::sse_encode(self.symbol, serializer);
        <Option<crate::models::Symbol>>::sse_encode(self.uniq_symbol, serializer);
        <Vec<crate::models::LocalizedName>>::sse_encode(self.localized_name, serializer);
        <Vec<crate::models::LocaleOverrides>>::sse_encode(self.locale_overrides, serializer);
    }
}

impl SseEncode for crate::errors::DepositClaimError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::errors::DepositClaimError::MaxDepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                required_fee_sats,
                required_fee_rate_sat_per_vbyte,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
                <Option<crate::models::Fee>>::sse_encode(max_fee, serializer);
                <u64>::sse_encode(required_fee_sats, serializer);
                <u64>::sse_encode(required_fee_rate_sat_per_vbyte, serializer);
            }
            crate::errors::DepositClaimError::MissingUtxo { tx, vout } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
            }
            crate::errors::DepositClaimError::Generic { message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::DepositInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
        <u64>::sse_encode(self.amount_sats, serializer);
        <Option<String>>::sse_encode(self.refund_tx, serializer);
        <Option<String>>::sse_encode(self.refund_tx_id, serializer);
        <Option<crate::errors::DepositClaimError>>::sse_encode(self.claim_error, serializer);
    }
}

impl SseEncode for crate::models::ExternalInputParser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.provider_id, serializer);
        <String>::sse_encode(self.input_regex, serializer);
        <String>::sse_encode(self.parser_url, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::Fee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::Fee::Fixed { amount } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(amount, serializer);
            }
            crate::models::Fee::Rate { sat_per_vbyte } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(sat_per_vbyte, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::FetchConversionLimitsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::ConversionType>::sse_encode(self.conversion_type, serializer);
        <Option<String>>::sse_encode(self.token_identifier, serializer);
    }
}

impl SseEncode for crate::models::FetchConversionLimitsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u128>>::sse_encode(self.min_from_amount, serializer);
        <Option<u128>>::sse_encode(self.min_to_amount, serializer);
    }
}

impl SseEncode for crate::models::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::models::CurrencyInfo>::sse_encode(self.info, serializer);
    }
}

impl SseEncode for crate::models::FreezeIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
    }
}

impl SseEncode for crate::models::FreezeIssuerTokenResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.impacted_output_ids, serializer);
        <u128>::sse_encode(self.impacted_token_amount, serializer);
    }
}

impl SseEncode for crate::models::GetInfoRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<bool>>::sse_encode(self.ensure_synced, serializer);
    }
}

impl SseEncode for crate::models::GetInfoResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.balance_sats, serializer);
        <std::collections::HashMap<String, crate::models::TokenBalance>>::sse_encode(
            self.token_balances,
            serializer,
        );
    }
}

impl SseEncode for crate::models::GetPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_id, serializer);
    }
}

impl SseEncode for crate::models::GetPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::GetTokensMetadataRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.token_identifiers, serializer);
    }
}

impl SseEncode for crate::models::GetTokensMetadataResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::TokenMetadata>>::sse_encode(self.tokens_metadata, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::InputType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::InputType::BitcoinAddress(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::models::BitcoinAddressDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt11Invoice(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::models::Bolt11InvoiceDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt12Invoice(field0) => {
                <i32>::sse_encode(2, serializer);
                <crate::models::Bolt12InvoiceDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt12Offer(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::models::Bolt12OfferDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LightningAddress(field0) => {
                <i32>::sse_encode(4, serializer);
                <crate::models::LightningAddressDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LnurlPay(field0) => {
                <i32>::sse_encode(5, serializer);
                <crate::models::LnurlPayRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::SilentPaymentAddress(field0) => {
                <i32>::sse_encode(6, serializer);
                <crate::models::SilentPaymentAddressDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LnurlAuth(field0) => {
                <i32>::sse_encode(7, serializer);
                <crate::models::LnurlAuthRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Url(field0) => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bip21(field0) => {
                <i32>::sse_encode(9, serializer);
                <crate::models::Bip21Details>::sse_encode(field0, serializer);
            }
            crate::models::InputType::Bolt12InvoiceRequest(field0) => {
                <i32>::sse_encode(10, serializer);
                <crate::models::Bolt12InvoiceRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::LnurlWithdraw(field0) => {
                <i32>::sse_encode(11, serializer);
                <crate::models::LnurlWithdrawRequestDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::SparkAddress(field0) => {
                <i32>::sse_encode(12, serializer);
                <crate::models::SparkAddressDetails>::sse_encode(field0, serializer);
            }
            crate::models::InputType::SparkInvoice(field0) => {
                <i32>::sse_encode(13, serializer);
                <crate::models::SparkInvoiceDetails>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::KeySetConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::KeySetType>::sse_encode(self.key_set_type, serializer);
        <bool>::sse_encode(self.use_address_index, serializer);
        <Option<u32>>::sse_encode(self.account_number, serializer);
    }
}

impl SseEncode for crate::models::KeySetType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::KeySetType::Default => 0,
                crate::models::KeySetType::Taproot => 1,
                crate::models::KeySetType::NativeSegwit => 2,
                crate::models::KeySetType::WrappedSegwit => 3,
                crate::models::KeySetType::Legacy => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::LightningAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <crate::models::LnurlPayRequestDetails>::sse_encode(self.pay_request, serializer);
    }
}

impl SseEncode for crate::models::LightningAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.lightning_address, serializer);
        <String>::sse_encode(self.lnurl, serializer);
        <String>::sse_encode(self.username, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bip21Extra> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bip21Extra>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bolt11RouteHint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bolt11RouteHint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bolt11RouteHintHop> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bolt11RouteHintHop>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Bolt12OfferBlindedPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Bolt12OfferBlindedPath>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::DepositInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::DepositInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::ExternalInputParser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::ExternalInputParser>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListFiatCurrenciesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::FiatCurrency>>::sse_encode(self.currencies, serializer);
    }
}

impl SseEncode for Vec<crate::models::FiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::FiatCurrency>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListFiatRatesResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::Rate>>::sse_encode(self.rates, serializer);
    }
}

impl SseEncode for Vec<crate::models::InputType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::InputType>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::LocaleOverrides> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::LocaleOverrides>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::LocalizedName> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::LocalizedName>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Payment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::PaymentDetailsFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::PaymentDetailsFilter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::PaymentStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::PaymentStatus>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::PaymentType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::PaymentType>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListPaymentsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<Vec<crate::models::PaymentType>>>::sse_encode(self.type_filter, serializer);
        <Option<Vec<crate::models::PaymentStatus>>>::sse_encode(self.status_filter, serializer);
        <Option<crate::models::AssetFilter>>::sse_encode(self.asset_filter, serializer);
        <Option<Vec<crate::models::PaymentDetailsFilter>>>::sse_encode(
            self.payment_details_filter,
            serializer,
        );
        <Option<u64>>::sse_encode(self.from_timestamp, serializer);
        <Option<u64>>::sse_encode(self.to_timestamp, serializer);
        <Option<u32>>::sse_encode(self.offset, serializer);
        <Option<u32>>::sse_encode(self.limit, serializer);
        <Option<bool>>::sse_encode(self.sort_ascending, serializer);
    }
}

impl SseEncode for crate::models::ListPaymentsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::Payment>>::sse_encode(self.payments, serializer);
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Rate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Rate>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::models::TokenBalance)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::models::TokenBalance)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::SparkHtlcStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::SparkHtlcStatus>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::TokenMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::TokenMetadata>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::ListUnclaimedDepositsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::ListUnclaimedDepositsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::DepositInfo>>::sse_encode(self.deposits, serializer);
    }
}

impl SseEncode for crate::models::LnurlAuthRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.k1, serializer);
        <Option<String>>::sse_encode(self.action, serializer);
        <String>::sse_encode(self.domain, serializer);
        <String>::sse_encode(self.url, serializer);
    }
}

impl SseEncode for crate::models::LnurlCallbackStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::LnurlCallbackStatus::Ok => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::LnurlCallbackStatus::ErrorStatus { error_details } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::LnurlErrorDetails>::sse_encode(error_details, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::LnurlErrorDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.reason, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.ln_address, serializer);
        <Option<String>>::sse_encode(self.comment, serializer);
        <Option<String>>::sse_encode(self.domain, serializer);
        <Option<String>>::sse_encode(self.metadata, serializer);
        <Option<crate::models::SuccessActionProcessed>>::sse_encode(
            self.processed_success_action,
            serializer,
        );
        <Option<crate::models::SuccessAction>>::sse_encode(self.raw_success_action, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::PrepareLnurlPayResponse>::sse_encode(self.prepare_response, serializer);
        <Option<String>>::sse_encode(self.idempotency_key, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.callback, serializer);
        <u64>::sse_encode(self.min_sendable, serializer);
        <u64>::sse_encode(self.max_sendable, serializer);
        <String>::sse_encode(self.metadata_str, serializer);
        <u16>::sse_encode(self.comment_allowed, serializer);
        <String>::sse_encode(self.domain, serializer);
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.address, serializer);
        <Option<bool>>::sse_encode(self.allows_nostr, serializer);
        <Option<String>>::sse_encode(self.nostr_pubkey, serializer);
    }
}

impl SseEncode for crate::models::LnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
        <Option<crate::models::SuccessActionProcessed>>::sse_encode(
            self.success_action,
            serializer,
        );
    }
}

impl SseEncode for crate::models::LnurlReceiveMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.nostr_zap_request, serializer);
        <Option<String>>::sse_encode(self.nostr_zap_receipt, serializer);
        <Option<String>>::sse_encode(self.sender_comment, serializer);
    }
}

impl SseEncode for crate::models::LnurlWithdrawInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.withdraw_url, serializer);
    }
}

impl SseEncode for crate::models::LnurlWithdrawRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.amount_sats, serializer);
        <crate::models::LnurlWithdrawRequestDetails>::sse_encode(self.withdraw_request, serializer);
        <Option<u32>>::sse_encode(self.completion_timeout_secs, serializer);
    }
}

impl SseEncode for crate::models::LnurlWithdrawRequestDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.callback, serializer);
        <String>::sse_encode(self.k1, serializer);
        <String>::sse_encode(self.default_description, serializer);
        <u64>::sse_encode(self.min_withdrawable, serializer);
        <u64>::sse_encode(self.max_withdrawable, serializer);
    }
}

impl SseEncode for crate::models::LnurlWithdrawResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_request, serializer);
        <Option<crate::models::Payment>>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::LocaleOverrides {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.locale, serializer);
        <Option<u32>>::sse_encode(self.spacing, serializer);
        <crate::models::Symbol>::sse_encode(self.symbol, serializer);
    }
}

impl SseEncode for crate::models::LocalizedName {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.locale, serializer);
        <String>::sse_encode(self.name, serializer);
    }
}

impl SseEncode for crate::logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.line, serializer);
        <String>::sse_encode(self.level, serializer);
    }
}

impl SseEncode for crate::models::MaxFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::MaxFee::Fixed { amount } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(amount, serializer);
            }
            crate::models::MaxFee::Rate { sat_per_vbyte } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(sat_per_vbyte, serializer);
            }
            crate::models::MaxFee::NetworkRecommended {
                leeway_sat_per_vbyte,
            } => {
                <i32>::sse_encode(2, serializer);
                <u64>::sse_encode(leeway_sat_per_vbyte, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::MessageSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for crate::models::MintIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::models::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::Network::Mainnet => 0,
                crate::models::Network::Regtest => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::OnchainConfirmationSpeed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::OnchainConfirmationSpeed::Fast => 0,
                crate::models::OnchainConfirmationSpeed::Medium => 1,
                crate::models::OnchainConfirmationSpeed::Slow => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u128>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Amount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Amount>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::AssetFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::AssetFilter>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::ConversionEstimate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::ConversionEstimate>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::ConversionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::ConversionInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::ConversionOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::ConversionOptions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::ConversionPurpose> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::ConversionPurpose>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Credentials> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Credentials>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::errors::DepositClaimError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::errors::DepositClaimError>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Fee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Fee>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::LightningAddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::LightningAddressInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::LnurlPayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::LnurlPayInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::LnurlReceiveMetadata> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::LnurlReceiveMetadata>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::LnurlWithdrawInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::LnurlWithdrawInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::MaxFee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::MaxFee>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Payment>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SendPaymentOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SendPaymentOptions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SparkHtlcDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SparkHtlcDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SparkHtlcOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SparkHtlcOptions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SparkInvoicePaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SparkInvoicePaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SuccessAction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SuccessAction>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::SuccessActionProcessed> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::SuccessActionProcessed>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::Symbol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::Symbol>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::ExternalInputParser>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::ExternalInputParser>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::PaymentDetailsFilter>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::PaymentDetailsFilter>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::PaymentStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::PaymentStatus>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::PaymentType>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::PaymentType>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::SparkHtlcStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::SparkHtlcStatus>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::OptimizationConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.auto_enabled, serializer);
        <u8>::sse_encode(self.multiplicity, serializer);
    }
}

impl SseEncode for crate::events::OptimizationEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::events::OptimizationEvent::Started { total_rounds } => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(total_rounds, serializer);
            }
            crate::events::OptimizationEvent::RoundCompleted {
                current_round,
                total_rounds,
            } => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(current_round, serializer);
                <u32>::sse_encode(total_rounds, serializer);
            }
            crate::events::OptimizationEvent::Completed => {
                <i32>::sse_encode(2, serializer);
            }
            crate::events::OptimizationEvent::Cancelled => {
                <i32>::sse_encode(3, serializer);
            }
            crate::events::OptimizationEvent::Failed { error } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(error, serializer);
            }
            crate::events::OptimizationEvent::Skipped => {
                <i32>::sse_encode(5, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::OptimizationProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_running, serializer);
        <u32>::sse_encode(self.current_round, serializer);
        <u32>::sse_encode(self.total_rounds, serializer);
    }
}

impl SseEncode for crate::models::Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::models::PaymentType>::sse_encode(self.payment_type, serializer);
        <crate::models::PaymentStatus>::sse_encode(self.status, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <u128>::sse_encode(self.fees, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
        <crate::models::PaymentMethod>::sse_encode(self.method, serializer);
        <Option<crate::models::PaymentDetails>>::sse_encode(self.details, serializer);
    }
}

impl SseEncode for crate::models::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::PaymentDetails::Spark {
                invoice_details,
                htlc_details,
                conversion_info,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<crate::models::SparkInvoicePaymentDetails>>::sse_encode(
                    invoice_details,
                    serializer,
                );
                <Option<crate::models::SparkHtlcDetails>>::sse_encode(htlc_details, serializer);
                <Option<crate::models::ConversionInfo>>::sse_encode(conversion_info, serializer);
            }
            crate::models::PaymentDetails::Token {
                metadata,
                tx_hash,
                invoice_details,
                conversion_info,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::TokenMetadata>::sse_encode(metadata, serializer);
                <String>::sse_encode(tx_hash, serializer);
                <Option<crate::models::SparkInvoicePaymentDetails>>::sse_encode(
                    invoice_details,
                    serializer,
                );
                <Option<crate::models::ConversionInfo>>::sse_encode(conversion_info, serializer);
            }
            crate::models::PaymentDetails::Lightning {
                description,
                preimage,
                invoice,
                payment_hash,
                destination_pubkey,
                lnurl_pay_info,
                lnurl_withdraw_info,
                lnurl_receive_metadata,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<String>>::sse_encode(description, serializer);
                <Option<String>>::sse_encode(preimage, serializer);
                <String>::sse_encode(invoice, serializer);
                <String>::sse_encode(payment_hash, serializer);
                <String>::sse_encode(destination_pubkey, serializer);
                <Option<crate::models::LnurlPayInfo>>::sse_encode(lnurl_pay_info, serializer);
                <Option<crate::models::LnurlWithdrawInfo>>::sse_encode(
                    lnurl_withdraw_info,
                    serializer,
                );
                <Option<crate::models::LnurlReceiveMetadata>>::sse_encode(
                    lnurl_receive_metadata,
                    serializer,
                );
            }
            crate::models::PaymentDetails::Withdraw { tx_id } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(tx_id, serializer);
            }
            crate::models::PaymentDetails::Deposit { tx_id } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(tx_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::PaymentDetailsFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::PaymentDetailsFilter::Spark {
                htlc_status,
                conversion_refund_needed,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<Vec<crate::models::SparkHtlcStatus>>>::sse_encode(htlc_status, serializer);
                <Option<bool>>::sse_encode(conversion_refund_needed, serializer);
            }
            crate::models::PaymentDetailsFilter::Token {
                conversion_refund_needed,
                tx_hash,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<bool>>::sse_encode(conversion_refund_needed, serializer);
                <Option<String>>::sse_encode(tx_hash, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::PaymentMethod::Lightning => 0,
                crate::models::PaymentMethod::Spark => 1,
                crate::models::PaymentMethod::Token => 2,
                crate::models::PaymentMethod::Deposit => 3,
                crate::models::PaymentMethod::Withdraw => 4,
                crate::models::PaymentMethod::Unknown => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::PaymentRequestSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.bip_21_uri, serializer);
        <Option<String>>::sse_encode(self.bip_353_address, serializer);
    }
}

impl SseEncode for crate::models::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::PaymentStatus::Completed => 0,
                crate::models::PaymentStatus::Pending => 1,
                crate::models::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::PaymentType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::PaymentType::Send => 0,
                crate::models::PaymentType::Receive => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::PrepareLnurlPayRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.amount_sats, serializer);
        <crate::models::LnurlPayRequestDetails>::sse_encode(self.pay_request, serializer);
        <Option<String>>::sse_encode(self.comment, serializer);
        <Option<bool>>::sse_encode(self.validate_success_action_url, serializer);
    }
}

impl SseEncode for crate::models::PrepareLnurlPayResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.amount_sats, serializer);
        <Option<String>>::sse_encode(self.comment, serializer);
        <crate::models::LnurlPayRequestDetails>::sse_encode(self.pay_request, serializer);
        <u64>::sse_encode(self.fee_sats, serializer);
        <crate::models::Bolt11InvoiceDetails>::sse_encode(self.invoice_details, serializer);
        <Option<crate::models::SuccessAction>>::sse_encode(self.success_action, serializer);
    }
}

impl SseEncode for crate::models::PrepareSendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_request, serializer);
        <Option<u128>>::sse_encode(self.amount, serializer);
        <Option<String>>::sse_encode(self.token_identifier, serializer);
        <Option<crate::models::ConversionOptions>>::sse_encode(self.conversion_options, serializer);
    }
}

impl SseEncode for crate::models::PrepareSendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::SendPaymentMethod>::sse_encode(self.payment_method, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <Option<String>>::sse_encode(self.token_identifier, serializer);
        <Option<crate::models::ConversionEstimate>>::sse_encode(
            self.conversion_estimate,
            serializer,
        );
    }
}

impl SseEncode for crate::models::Rate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.coin, serializer);
        <f64>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::ReceivePaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::ReceivePaymentMethod::SparkAddress => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::ReceivePaymentMethod::SparkInvoice {
                amount,
                token_identifier,
                expiry_time,
                description,
                sender_public_key,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<u128>>::sse_encode(amount, serializer);
                <Option<String>>::sse_encode(token_identifier, serializer);
                <Option<u64>>::sse_encode(expiry_time, serializer);
                <Option<String>>::sse_encode(description, serializer);
                <Option<String>>::sse_encode(sender_public_key, serializer);
            }
            crate::models::ReceivePaymentMethod::BitcoinAddress => {
                <i32>::sse_encode(2, serializer);
            }
            crate::models::ReceivePaymentMethod::Bolt11Invoice {
                description,
                amount_sats,
                expiry_secs,
            } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(description, serializer);
                <Option<u64>>::sse_encode(amount_sats, serializer);
                <Option<u32>>::sse_encode(expiry_secs, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::ReceivePaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::ReceivePaymentMethod>::sse_encode(self.payment_method, serializer);
    }
}

impl SseEncode for crate::models::ReceivePaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_request, serializer);
        <u128>::sse_encode(self.fee, serializer);
    }
}

impl SseEncode for crate::models::RecommendedFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.fastest_fee, serializer);
        <u64>::sse_encode(self.half_hour_fee, serializer);
        <u64>::sse_encode(self.hour_fee, serializer);
        <u64>::sse_encode(self.economy_fee, serializer);
        <u64>::sse_encode(self.minimum_fee, serializer);
    }
}

impl SseEncode for (String, crate::models::TokenBalance) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::models::TokenBalance>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::models::RefundDepositRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
        <String>::sse_encode(self.destination_address, serializer);
        <crate::models::Fee>::sse_encode(self.fee, serializer);
    }
}

impl SseEncode for crate::models::RefundDepositResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.tx_id, serializer);
        <String>::sse_encode(self.tx_hex, serializer);
    }
}

impl SseEncode for crate::models::RegisterLightningAddressRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
    }
}

impl SseEncode for crate::errors::SdkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::errors::SdkError::SparkError(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::InsufficientFunds => {
                <i32>::sse_encode(1, serializer);
            }
            crate::errors::SdkError::InvalidUuid(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::InvalidInput(field0) => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::NetworkError(field0) => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::StorageError(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::ChainServiceError(field0) => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::MaxDepositClaimFeeExceeded {
                tx,
                vout,
                max_fee,
                required_fee_sats,
                required_fee_rate_sat_per_vbyte,
            } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
                <Option<crate::models::Fee>>::sse_encode(max_fee, serializer);
                <u64>::sse_encode(required_fee_sats, serializer);
                <u64>::sse_encode(required_fee_rate_sat_per_vbyte, serializer);
            }
            crate::errors::SdkError::MissingUtxo { tx, vout } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(tx, serializer);
                <u32>::sse_encode(vout, serializer);
            }
            crate::errors::SdkError::LnurlError(field0) => {
                <i32>::sse_encode(9, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::Signer(field0) => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::errors::SdkError::Generic(field0) => {
                <i32>::sse_encode(11, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::events::SdkEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::events::SdkEvent::Synced => {
                <i32>::sse_encode(0, serializer);
            }
            crate::events::SdkEvent::UnclaimedDeposits { unclaimed_deposits } => {
                <i32>::sse_encode(1, serializer);
                <Vec<crate::models::DepositInfo>>::sse_encode(unclaimed_deposits, serializer);
            }
            crate::events::SdkEvent::ClaimedDeposits { claimed_deposits } => {
                <i32>::sse_encode(2, serializer);
                <Vec<crate::models::DepositInfo>>::sse_encode(claimed_deposits, serializer);
            }
            crate::events::SdkEvent::PaymentSucceeded { payment } => {
                <i32>::sse_encode(3, serializer);
                <crate::models::Payment>::sse_encode(payment, serializer);
            }
            crate::events::SdkEvent::PaymentPending { payment } => {
                <i32>::sse_encode(4, serializer);
                <crate::models::Payment>::sse_encode(payment, serializer);
            }
            crate::events::SdkEvent::PaymentFailed { payment } => {
                <i32>::sse_encode(5, serializer);
                <crate::models::Payment>::sse_encode(payment, serializer);
            }
            crate::events::SdkEvent::Optimization { optimization_event } => {
                <i32>::sse_encode(6, serializer);
                <crate::events::OptimizationEvent>::sse_encode(optimization_event, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Seed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::Seed::Mnemonic {
                mnemonic,
                passphrase,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(mnemonic, serializer);
                <Option<String>>::sse_encode(passphrase, serializer);
            }
            crate::models::Seed::Entropy(field0) => {
                <i32>::sse_encode(1, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SendOnchainFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u64>::sse_encode(self.expires_at, serializer);
        <crate::models::SendOnchainSpeedFeeQuote>::sse_encode(self.speed_fast, serializer);
        <crate::models::SendOnchainSpeedFeeQuote>::sse_encode(self.speed_medium, serializer);
        <crate::models::SendOnchainSpeedFeeQuote>::sse_encode(self.speed_slow, serializer);
    }
}

impl SseEncode for crate::models::SendOnchainSpeedFeeQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.user_fee_sat, serializer);
        <u64>::sse_encode(self.l1_broadcast_fee_sat, serializer);
    }
}

impl SseEncode for crate::models::SendPaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SendPaymentMethod::BitcoinAddress { address, fee_quote } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::BitcoinAddressDetails>::sse_encode(address, serializer);
                <crate::models::SendOnchainFeeQuote>::sse_encode(fee_quote, serializer);
            }
            crate::models::SendPaymentMethod::Bolt11Invoice {
                invoice_details,
                spark_transfer_fee_sats,
                lightning_fee_sats,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::Bolt11InvoiceDetails>::sse_encode(invoice_details, serializer);
                <Option<u64>>::sse_encode(spark_transfer_fee_sats, serializer);
                <u64>::sse_encode(lightning_fee_sats, serializer);
            }
            crate::models::SendPaymentMethod::SparkAddress {
                address,
                fee,
                token_identifier,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(address, serializer);
                <u128>::sse_encode(fee, serializer);
                <Option<String>>::sse_encode(token_identifier, serializer);
            }
            crate::models::SendPaymentMethod::SparkInvoice {
                spark_invoice_details,
                fee,
                token_identifier,
            } => {
                <i32>::sse_encode(3, serializer);
                <crate::models::SparkInvoiceDetails>::sse_encode(spark_invoice_details, serializer);
                <u128>::sse_encode(fee, serializer);
                <Option<String>>::sse_encode(token_identifier, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SendPaymentOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SendPaymentOptions::BitcoinAddress { confirmation_speed } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::OnchainConfirmationSpeed>::sse_encode(
                    confirmation_speed,
                    serializer,
                );
            }
            crate::models::SendPaymentOptions::Bolt11Invoice {
                prefer_spark,
                completion_timeout_secs,
            } => {
                <i32>::sse_encode(1, serializer);
                <bool>::sse_encode(prefer_spark, serializer);
                <Option<u32>>::sse_encode(completion_timeout_secs, serializer);
            }
            crate::models::SendPaymentOptions::SparkAddress { htlc_options } => {
                <i32>::sse_encode(2, serializer);
                <Option<crate::models::SparkHtlcOptions>>::sse_encode(htlc_options, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SendPaymentRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::PrepareSendPaymentResponse>::sse_encode(self.prepare_response, serializer);
        <Option<crate::models::SendPaymentOptions>>::sse_encode(self.options, serializer);
        <Option<String>>::sse_encode(self.idempotency_key, serializer);
    }
}

impl SseEncode for crate::models::SendPaymentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::Payment>::sse_encode(self.payment, serializer);
    }
}

impl SseEncode for crate::models::SignMessageRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
        <bool>::sse_encode(self.compact, serializer);
    }
}

impl SseEncode for crate::models::SignMessageResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.pubkey, serializer);
        <String>::sse_encode(self.signature, serializer);
    }
}

impl SseEncode for crate::models::SilentPaymentAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::SparkAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <String>::sse_encode(self.identity_public_key, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <crate::models::PaymentRequestSource>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::models::SparkHtlcDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_hash, serializer);
        <Option<String>>::sse_encode(self.preimage, serializer);
        <u64>::sse_encode(self.expiry_time, serializer);
        <crate::models::SparkHtlcStatus>::sse_encode(self.status, serializer);
    }
}

impl SseEncode for crate::models::SparkHtlcOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.payment_hash, serializer);
        <u64>::sse_encode(self.expiry_duration_secs, serializer);
    }
}

impl SseEncode for crate::models::SparkHtlcStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::SparkHtlcStatus::WaitingForPreimage => 0,
                crate::models::SparkHtlcStatus::PreimageShared => 1,
                crate::models::SparkHtlcStatus::Returned => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::SparkInvoiceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.invoice, serializer);
        <String>::sse_encode(self.identity_public_key, serializer);
        <crate::models::BitcoinNetwork>::sse_encode(self.network, serializer);
        <Option<u128>>::sse_encode(self.amount, serializer);
        <Option<String>>::sse_encode(self.token_identifier, serializer);
        <Option<u64>>::sse_encode(self.expiry_time, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<String>>::sse_encode(self.sender_public_key, serializer);
    }
}

impl SseEncode for crate::models::SparkInvoicePaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.invoice, serializer);
    }
}

impl SseEncode for crate::models::SuccessAction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SuccessAction::Aes { data } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::AesSuccessActionData>::sse_encode(data, serializer);
            }
            crate::models::SuccessAction::Message { data } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::MessageSuccessActionData>::sse_encode(data, serializer);
            }
            crate::models::SuccessAction::Url { data } => {
                <i32>::sse_encode(2, serializer);
                <crate::models::UrlSuccessActionData>::sse_encode(data, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::SuccessActionProcessed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::SuccessActionProcessed::Aes { result } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::AesSuccessActionDataResult>::sse_encode(result, serializer);
            }
            crate::models::SuccessActionProcessed::Message { data } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::MessageSuccessActionData>::sse_encode(data, serializer);
            }
            crate::models::SuccessActionProcessed::Url { data } => {
                <i32>::sse_encode(2, serializer);
                <crate::models::UrlSuccessActionData>::sse_encode(data, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::Symbol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.grapheme, serializer);
        <Option<String>>::sse_encode(self.template, serializer);
        <Option<bool>>::sse_encode(self.rtl, serializer);
        <Option<u32>>::sse_encode(self.position, serializer);
    }
}

impl SseEncode for crate::models::SyncWalletRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::SyncWalletResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::TokenBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.balance, serializer);
        <crate::models::TokenMetadata>::sse_encode(self.token_metadata, serializer);
    }
}

impl SseEncode for crate::models::TokenMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.identifier, serializer);
        <String>::sse_encode(self.issuer_public_key, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.ticker, serializer);
        <u32>::sse_encode(self.decimals, serializer);
        <u128>::sse_encode(self.max_supply, serializer);
        <bool>::sse_encode(self.is_freezable, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for crate::models::UnfreezeIssuerTokenRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
    }
}

impl SseEncode for crate::models::UnfreezeIssuerTokenResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.impacted_output_ids, serializer);
        <u128>::sse_encode(self.impacted_token_amount, serializer);
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::UpdateUserSettingsRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<bool>>::sse_encode(self.spark_private_mode_enabled, serializer);
    }
}

impl SseEncode for crate::models::UrlSuccessActionData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.url, serializer);
        <bool>::sse_encode(self.matches_callback_domain, serializer);
    }
}

impl SseEncode for crate::models::UserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.spark_private_mode_enabled, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use crate::issuer::*;
    use crate::sdk::*;
    use crate::sdk_builder::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBreezSdk(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBreezSdk(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdk>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SdkBuilder>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTokenIssuer(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< TokenIssuer>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_breez_sdk_spark_flutter_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTokenIssuer(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< TokenIssuer>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
