// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'errors.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'models.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `IncomingChange`, `OutgoingChange`, `PaymentMetadata`, `RecordChange`, `RecordId`, `Record`, `SparkInvoicePaymentType`, `UnversionedRecordChange`, `UpdateDepositPayload`

class AesSuccessActionData {
  final String description;
  final String ciphertext;
  final String iv;

  const AesSuccessActionData({required this.description, required this.ciphertext, required this.iv});

  @override
  int get hashCode => description.hashCode ^ ciphertext.hashCode ^ iv.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AesSuccessActionData &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          ciphertext == other.ciphertext &&
          iv == other.iv;
}

class AesSuccessActionDataDecrypted {
  final String description;
  final String plaintext;

  const AesSuccessActionDataDecrypted({required this.description, required this.plaintext});

  @override
  int get hashCode => description.hashCode ^ plaintext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AesSuccessActionDataDecrypted &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          plaintext == other.plaintext;
}

@freezed
sealed class AesSuccessActionDataResult with _$AesSuccessActionDataResult {
  const AesSuccessActionDataResult._();

  const factory AesSuccessActionDataResult.decrypted({required AesSuccessActionDataDecrypted data}) =
      AesSuccessActionDataResult_Decrypted;
  const factory AesSuccessActionDataResult.errorStatus({required String reason}) =
      AesSuccessActionDataResult_ErrorStatus;
}

@freezed
sealed class Amount with _$Amount {
  const Amount._();

  const factory Amount.bitcoin({required BigInt amountMsat}) = Amount_Bitcoin;
  const factory Amount.currency({required String iso4217Code, required BigInt fractionalAmount}) =
      Amount_Currency;
}

@freezed
sealed class AssetFilter with _$AssetFilter {
  const AssetFilter._();

  const factory AssetFilter.bitcoin() = AssetFilter_Bitcoin;
  const factory AssetFilter.token({String? tokenIdentifier}) = AssetFilter_Token;
}

class Bip21Details {
  final BigInt? amountSat;
  final String? assetId;
  final String uri;
  final List<Bip21Extra> extras;
  final String? label;
  final String? message;
  final List<InputType> paymentMethods;

  const Bip21Details({
    this.amountSat,
    this.assetId,
    required this.uri,
    required this.extras,
    this.label,
    this.message,
    required this.paymentMethods,
  });

  @override
  int get hashCode =>
      amountSat.hashCode ^
      assetId.hashCode ^
      uri.hashCode ^
      extras.hashCode ^
      label.hashCode ^
      message.hashCode ^
      paymentMethods.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bip21Details &&
          runtimeType == other.runtimeType &&
          amountSat == other.amountSat &&
          assetId == other.assetId &&
          uri == other.uri &&
          extras == other.extras &&
          label == other.label &&
          message == other.message &&
          paymentMethods == other.paymentMethods;
}

class Bip21Extra {
  final String key;
  final String value;

  const Bip21Extra({required this.key, required this.value});

  @override
  int get hashCode => key.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bip21Extra && runtimeType == other.runtimeType && key == other.key && value == other.value;
}

class BitcoinAddressDetails {
  final String address;
  final BitcoinNetwork network;
  final PaymentRequestSource source;

  const BitcoinAddressDetails({required this.address, required this.network, required this.source});

  @override
  int get hashCode => address.hashCode ^ network.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BitcoinAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          network == other.network &&
          source == other.source;
}

enum BitcoinNetwork { bitcoin, testnet3, testnet4, signet, regtest }

class Bolt11Invoice {
  final String bolt11;
  final PaymentRequestSource source;

  const Bolt11Invoice({required this.bolt11, required this.source});

  @override
  int get hashCode => bolt11.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11Invoice &&
          runtimeType == other.runtimeType &&
          bolt11 == other.bolt11 &&
          source == other.source;
}

class Bolt11InvoiceDetails {
  final BigInt? amountMsat;
  final String? description;
  final String? descriptionHash;
  final BigInt expiry;
  final Bolt11Invoice invoice;
  final BigInt minFinalCltvExpiryDelta;
  final BitcoinNetwork network;
  final String payeePubkey;
  final String paymentHash;
  final String paymentSecret;
  final List<Bolt11RouteHint> routingHints;
  final BigInt timestamp;

  const Bolt11InvoiceDetails({
    this.amountMsat,
    this.description,
    this.descriptionHash,
    required this.expiry,
    required this.invoice,
    required this.minFinalCltvExpiryDelta,
    required this.network,
    required this.payeePubkey,
    required this.paymentHash,
    required this.paymentSecret,
    required this.routingHints,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      amountMsat.hashCode ^
      description.hashCode ^
      descriptionHash.hashCode ^
      expiry.hashCode ^
      invoice.hashCode ^
      minFinalCltvExpiryDelta.hashCode ^
      network.hashCode ^
      payeePubkey.hashCode ^
      paymentHash.hashCode ^
      paymentSecret.hashCode ^
      routingHints.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11InvoiceDetails &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          description == other.description &&
          descriptionHash == other.descriptionHash &&
          expiry == other.expiry &&
          invoice == other.invoice &&
          minFinalCltvExpiryDelta == other.minFinalCltvExpiryDelta &&
          network == other.network &&
          payeePubkey == other.payeePubkey &&
          paymentHash == other.paymentHash &&
          paymentSecret == other.paymentSecret &&
          routingHints == other.routingHints &&
          timestamp == other.timestamp;
}

class Bolt11RouteHint {
  final List<Bolt11RouteHintHop> hops;

  const Bolt11RouteHint({required this.hops});

  @override
  int get hashCode => hops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11RouteHint && runtimeType == other.runtimeType && hops == other.hops;
}

class Bolt11RouteHintHop {
  final String srcNodeId;
  final String shortChannelId;
  final int feesBaseMsat;
  final int feesProportionalMillionths;
  final int cltvExpiryDelta;
  final BigInt? htlcMinimumMsat;
  final BigInt? htlcMaximumMsat;

  const Bolt11RouteHintHop({
    required this.srcNodeId,
    required this.shortChannelId,
    required this.feesBaseMsat,
    required this.feesProportionalMillionths,
    required this.cltvExpiryDelta,
    this.htlcMinimumMsat,
    this.htlcMaximumMsat,
  });

  @override
  int get hashCode =>
      srcNodeId.hashCode ^
      shortChannelId.hashCode ^
      feesBaseMsat.hashCode ^
      feesProportionalMillionths.hashCode ^
      cltvExpiryDelta.hashCode ^
      htlcMinimumMsat.hashCode ^
      htlcMaximumMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11RouteHintHop &&
          runtimeType == other.runtimeType &&
          srcNodeId == other.srcNodeId &&
          shortChannelId == other.shortChannelId &&
          feesBaseMsat == other.feesBaseMsat &&
          feesProportionalMillionths == other.feesProportionalMillionths &&
          cltvExpiryDelta == other.cltvExpiryDelta &&
          htlcMinimumMsat == other.htlcMinimumMsat &&
          htlcMaximumMsat == other.htlcMaximumMsat;
}

class Bolt12Invoice {
  final String invoice;
  final PaymentRequestSource source;

  const Bolt12Invoice({required this.invoice, required this.source});

  @override
  int get hashCode => invoice.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12Invoice &&
          runtimeType == other.runtimeType &&
          invoice == other.invoice &&
          source == other.source;
}

class Bolt12InvoiceDetails {
  final BigInt amountMsat;
  final Bolt12Invoice invoice;

  const Bolt12InvoiceDetails({required this.amountMsat, required this.invoice});

  @override
  int get hashCode => amountMsat.hashCode ^ invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12InvoiceDetails &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          invoice == other.invoice;
}

class Bolt12InvoiceRequestDetails {
  const Bolt12InvoiceRequestDetails();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is Bolt12InvoiceRequestDetails && runtimeType == other.runtimeType;
}

class Bolt12Offer {
  final String offer;
  final PaymentRequestSource source;

  const Bolt12Offer({required this.offer, required this.source});

  @override
  int get hashCode => offer.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12Offer &&
          runtimeType == other.runtimeType &&
          offer == other.offer &&
          source == other.source;
}

class Bolt12OfferBlindedPath {
  final List<String> blindedHops;

  const Bolt12OfferBlindedPath({required this.blindedHops});

  @override
  int get hashCode => blindedHops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12OfferBlindedPath && runtimeType == other.runtimeType && blindedHops == other.blindedHops;
}

class Bolt12OfferDetails {
  final BigInt? absoluteExpiry;
  final List<String> chains;
  final String? description;
  final String? issuer;
  final Amount? minAmount;
  final Bolt12Offer offer;
  final List<Bolt12OfferBlindedPath> paths;
  final String? signingPubkey;

  const Bolt12OfferDetails({
    this.absoluteExpiry,
    required this.chains,
    this.description,
    this.issuer,
    this.minAmount,
    required this.offer,
    required this.paths,
    this.signingPubkey,
  });

  @override
  int get hashCode =>
      absoluteExpiry.hashCode ^
      chains.hashCode ^
      description.hashCode ^
      issuer.hashCode ^
      minAmount.hashCode ^
      offer.hashCode ^
      paths.hashCode ^
      signingPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12OfferDetails &&
          runtimeType == other.runtimeType &&
          absoluteExpiry == other.absoluteExpiry &&
          chains == other.chains &&
          description == other.description &&
          issuer == other.issuer &&
          minAmount == other.minAmount &&
          offer == other.offer &&
          paths == other.paths &&
          signingPubkey == other.signingPubkey;
}

class BurnIssuerTokenRequest {
  final BigInt amount;

  const BurnIssuerTokenRequest({required this.amount});

  @override
  int get hashCode => amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BurnIssuerTokenRequest && runtimeType == other.runtimeType && amount == other.amount;
}

enum ChainApiType { esplora, mempoolSpace }

class CheckLightningAddressRequest {
  final String username;

  const CheckLightningAddressRequest({required this.username});

  @override
  int get hashCode => username.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckLightningAddressRequest && runtimeType == other.runtimeType && username == other.username;
}

class CheckMessageRequest {
  final String message;
  final String pubkey;
  final String signature;

  const CheckMessageRequest({required this.message, required this.pubkey, required this.signature});

  @override
  int get hashCode => message.hashCode ^ pubkey.hashCode ^ signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckMessageRequest &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          pubkey == other.pubkey &&
          signature == other.signature;
}

class CheckMessageResponse {
  final bool isValid;

  const CheckMessageResponse({required this.isValid});

  @override
  int get hashCode => isValid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckMessageResponse && runtimeType == other.runtimeType && isValid == other.isValid;
}

class ClaimDepositRequest {
  final String txid;
  final int vout;
  final MaxFee? maxFee;

  const ClaimDepositRequest({required this.txid, required this.vout, this.maxFee});

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode ^ maxFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimDepositRequest &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          maxFee == other.maxFee;
}

class ClaimDepositResponse {
  final Payment payment;

  const ClaimDepositResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimDepositResponse && runtimeType == other.runtimeType && payment == other.payment;
}

class ClaimHtlcPaymentRequest {
  final String preimage;

  const ClaimHtlcPaymentRequest({required this.preimage});

  @override
  int get hashCode => preimage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimHtlcPaymentRequest && runtimeType == other.runtimeType && preimage == other.preimage;
}

class ClaimHtlcPaymentResponse {
  final Payment payment;

  const ClaimHtlcPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimHtlcPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

class Config {
  final String? apiKey;
  final Network network;
  final int syncIntervalSecs;
  final MaxFee? maxDepositClaimFee;
  final String? lnurlDomain;
  final bool preferSparkOverLightning;
  final List<ExternalInputParser>? externalInputParsers;
  final bool useDefaultExternalInputParsers;
  final String? realTimeSyncServerUrl;
  final bool privateEnabledDefault;
  final OptimizationConfig optimizationConfig;

  const Config({
    this.apiKey,
    required this.network,
    required this.syncIntervalSecs,
    this.maxDepositClaimFee,
    this.lnurlDomain,
    required this.preferSparkOverLightning,
    this.externalInputParsers,
    required this.useDefaultExternalInputParsers,
    this.realTimeSyncServerUrl,
    required this.privateEnabledDefault,
    required this.optimizationConfig,
  });

  @override
  int get hashCode =>
      apiKey.hashCode ^
      network.hashCode ^
      syncIntervalSecs.hashCode ^
      maxDepositClaimFee.hashCode ^
      lnurlDomain.hashCode ^
      preferSparkOverLightning.hashCode ^
      externalInputParsers.hashCode ^
      useDefaultExternalInputParsers.hashCode ^
      realTimeSyncServerUrl.hashCode ^
      privateEnabledDefault.hashCode ^
      optimizationConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          apiKey == other.apiKey &&
          network == other.network &&
          syncIntervalSecs == other.syncIntervalSecs &&
          maxDepositClaimFee == other.maxDepositClaimFee &&
          lnurlDomain == other.lnurlDomain &&
          preferSparkOverLightning == other.preferSparkOverLightning &&
          externalInputParsers == other.externalInputParsers &&
          useDefaultExternalInputParsers == other.useDefaultExternalInputParsers &&
          realTimeSyncServerUrl == other.realTimeSyncServerUrl &&
          privateEnabledDefault == other.privateEnabledDefault &&
          optimizationConfig == other.optimizationConfig;
}

class ConnectRequest {
  final Config config;
  final Seed seed;
  final String storageDir;

  const ConnectRequest({required this.config, required this.seed, required this.storageDir});

  @override
  int get hashCode => config.hashCode ^ seed.hashCode ^ storageDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectRequest &&
          runtimeType == other.runtimeType &&
          config == other.config &&
          seed == other.seed &&
          storageDir == other.storageDir;
}

class ConversionEstimate {
  final ConversionOptions options;
  final BigInt amount;
  final BigInt fee;

  const ConversionEstimate({required this.options, required this.amount, required this.fee});

  @override
  int get hashCode => options.hashCode ^ amount.hashCode ^ fee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversionEstimate &&
          runtimeType == other.runtimeType &&
          options == other.options &&
          amount == other.amount &&
          fee == other.fee;
}

class ConversionInfo {
  final String poolId;
  final String conversionId;
  final ConversionStatus status;
  final BigInt? fee;
  final ConversionPurpose? purpose;

  const ConversionInfo({
    required this.poolId,
    required this.conversionId,
    required this.status,
    this.fee,
    this.purpose,
  });

  @override
  int get hashCode =>
      poolId.hashCode ^ conversionId.hashCode ^ status.hashCode ^ fee.hashCode ^ purpose.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversionInfo &&
          runtimeType == other.runtimeType &&
          poolId == other.poolId &&
          conversionId == other.conversionId &&
          status == other.status &&
          fee == other.fee &&
          purpose == other.purpose;
}

class ConversionOptions {
  final ConversionType conversionType;
  final int? maxSlippageBps;
  final int? completionTimeoutSecs;

  const ConversionOptions({required this.conversionType, this.maxSlippageBps, this.completionTimeoutSecs});

  @override
  int get hashCode => conversionType.hashCode ^ maxSlippageBps.hashCode ^ completionTimeoutSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversionOptions &&
          runtimeType == other.runtimeType &&
          conversionType == other.conversionType &&
          maxSlippageBps == other.maxSlippageBps &&
          completionTimeoutSecs == other.completionTimeoutSecs;
}

@freezed
sealed class ConversionPurpose with _$ConversionPurpose {
  const ConversionPurpose._();

  const factory ConversionPurpose.ongoingPayment({required String paymentRequest}) =
      ConversionPurpose_OngoingPayment;
  const factory ConversionPurpose.selfTransfer() = ConversionPurpose_SelfTransfer;
}

enum ConversionStatus { completed, refundNeeded, refunded }

@freezed
sealed class ConversionType with _$ConversionType {
  const ConversionType._();

  const factory ConversionType.fromBitcoin() = ConversionType_FromBitcoin;
  const factory ConversionType.toBitcoin({required String fromTokenIdentifier}) = ConversionType_ToBitcoin;
}

class CreateIssuerTokenRequest {
  final String name;
  final String ticker;
  final int decimals;
  final bool isFreezable;
  final BigInt maxSupply;

  const CreateIssuerTokenRequest({
    required this.name,
    required this.ticker,
    required this.decimals,
    required this.isFreezable,
    required this.maxSupply,
  });

  @override
  int get hashCode =>
      name.hashCode ^ ticker.hashCode ^ decimals.hashCode ^ isFreezable.hashCode ^ maxSupply.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateIssuerTokenRequest &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          ticker == other.ticker &&
          decimals == other.decimals &&
          isFreezable == other.isFreezable &&
          maxSupply == other.maxSupply;
}

class Credentials {
  final String username;
  final String password;

  const Credentials({required this.username, required this.password});

  @override
  int get hashCode => username.hashCode ^ password.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Credentials &&
          runtimeType == other.runtimeType &&
          username == other.username &&
          password == other.password;
}

class CurrencyInfo {
  final String name;
  final int fractionSize;
  final int? spacing;
  final Symbol? symbol;
  final Symbol? uniqSymbol;
  final List<LocalizedName> localizedName;
  final List<LocaleOverrides> localeOverrides;

  const CurrencyInfo({
    required this.name,
    required this.fractionSize,
    this.spacing,
    this.symbol,
    this.uniqSymbol,
    required this.localizedName,
    required this.localeOverrides,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      fractionSize.hashCode ^
      spacing.hashCode ^
      symbol.hashCode ^
      uniqSymbol.hashCode ^
      localizedName.hashCode ^
      localeOverrides.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CurrencyInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          fractionSize == other.fractionSize &&
          spacing == other.spacing &&
          symbol == other.symbol &&
          uniqSymbol == other.uniqSymbol &&
          localizedName == other.localizedName &&
          localeOverrides == other.localeOverrides;
}

class DepositInfo {
  final String txid;
  final int vout;
  final BigInt amountSats;
  final String? refundTx;
  final String? refundTxId;
  final DepositClaimError? claimError;

  const DepositInfo({
    required this.txid,
    required this.vout,
    required this.amountSats,
    this.refundTx,
    this.refundTxId,
    this.claimError,
  });

  @override
  int get hashCode =>
      txid.hashCode ^
      vout.hashCode ^
      amountSats.hashCode ^
      refundTx.hashCode ^
      refundTxId.hashCode ^
      claimError.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DepositInfo &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          amountSats == other.amountSats &&
          refundTx == other.refundTx &&
          refundTxId == other.refundTxId &&
          claimError == other.claimError;
}

class ExternalInputParser {
  final String providerId;
  final String inputRegex;
  final String parserUrl;

  const ExternalInputParser({required this.providerId, required this.inputRegex, required this.parserUrl});

  @override
  int get hashCode => providerId.hashCode ^ inputRegex.hashCode ^ parserUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExternalInputParser &&
          runtimeType == other.runtimeType &&
          providerId == other.providerId &&
          inputRegex == other.inputRegex &&
          parserUrl == other.parserUrl;
}

@freezed
sealed class Fee with _$Fee {
  const Fee._();

  const factory Fee.fixed({required BigInt amount}) = Fee_Fixed;
  const factory Fee.rate({required BigInt satPerVbyte}) = Fee_Rate;
}

class FetchConversionLimitsRequest {
  final ConversionType conversionType;
  final String? tokenIdentifier;

  const FetchConversionLimitsRequest({required this.conversionType, this.tokenIdentifier});

  @override
  int get hashCode => conversionType.hashCode ^ tokenIdentifier.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FetchConversionLimitsRequest &&
          runtimeType == other.runtimeType &&
          conversionType == other.conversionType &&
          tokenIdentifier == other.tokenIdentifier;
}

class FetchConversionLimitsResponse {
  final BigInt? minFromAmount;
  final BigInt? minToAmount;

  const FetchConversionLimitsResponse({this.minFromAmount, this.minToAmount});

  @override
  int get hashCode => minFromAmount.hashCode ^ minToAmount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FetchConversionLimitsResponse &&
          runtimeType == other.runtimeType &&
          minFromAmount == other.minFromAmount &&
          minToAmount == other.minToAmount;
}

class FiatCurrency {
  final String id;
  final CurrencyInfo info;

  const FiatCurrency({required this.id, required this.info});

  @override
  int get hashCode => id.hashCode ^ info.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FiatCurrency && runtimeType == other.runtimeType && id == other.id && info == other.info;
}

class FreezeIssuerTokenRequest {
  final String address;

  const FreezeIssuerTokenRequest({required this.address});

  @override
  int get hashCode => address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FreezeIssuerTokenRequest && runtimeType == other.runtimeType && address == other.address;
}

class FreezeIssuerTokenResponse {
  final List<String> impactedOutputIds;
  final BigInt impactedTokenAmount;

  const FreezeIssuerTokenResponse({required this.impactedOutputIds, required this.impactedTokenAmount});

  @override
  int get hashCode => impactedOutputIds.hashCode ^ impactedTokenAmount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FreezeIssuerTokenResponse &&
          runtimeType == other.runtimeType &&
          impactedOutputIds == other.impactedOutputIds &&
          impactedTokenAmount == other.impactedTokenAmount;
}

class GetInfoRequest {
  final bool? ensureSynced;

  const GetInfoRequest({this.ensureSynced});

  @override
  int get hashCode => ensureSynced.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetInfoRequest && runtimeType == other.runtimeType && ensureSynced == other.ensureSynced;
}

class GetInfoResponse {
  final BigInt balanceSats;
  final Map<String, TokenBalance> tokenBalances;

  const GetInfoResponse({required this.balanceSats, required this.tokenBalances});

  @override
  int get hashCode => balanceSats.hashCode ^ tokenBalances.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetInfoResponse &&
          runtimeType == other.runtimeType &&
          balanceSats == other.balanceSats &&
          tokenBalances == other.tokenBalances;
}

class GetPaymentRequest {
  final String paymentId;

  const GetPaymentRequest({required this.paymentId});

  @override
  int get hashCode => paymentId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetPaymentRequest && runtimeType == other.runtimeType && paymentId == other.paymentId;
}

class GetPaymentResponse {
  final Payment payment;

  const GetPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

class GetTokensMetadataRequest {
  final List<String> tokenIdentifiers;

  const GetTokensMetadataRequest({required this.tokenIdentifiers});

  @override
  int get hashCode => tokenIdentifiers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetTokensMetadataRequest &&
          runtimeType == other.runtimeType &&
          tokenIdentifiers == other.tokenIdentifiers;
}

class GetTokensMetadataResponse {
  final List<TokenMetadata> tokensMetadata;

  const GetTokensMetadataResponse({required this.tokensMetadata});

  @override
  int get hashCode => tokensMetadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetTokensMetadataResponse &&
          runtimeType == other.runtimeType &&
          tokensMetadata == other.tokensMetadata;
}

@freezed
sealed class InputType with _$InputType {
  const InputType._();

  const factory InputType.bitcoinAddress(BitcoinAddressDetails field0) = InputType_BitcoinAddress;
  const factory InputType.bolt11Invoice(Bolt11InvoiceDetails field0) = InputType_Bolt11Invoice;
  const factory InputType.bolt12Invoice(Bolt12InvoiceDetails field0) = InputType_Bolt12Invoice;
  const factory InputType.bolt12Offer(Bolt12OfferDetails field0) = InputType_Bolt12Offer;
  const factory InputType.lightningAddress(LightningAddressDetails field0) = InputType_LightningAddress;
  const factory InputType.lnurlPay(LnurlPayRequestDetails field0) = InputType_LnurlPay;
  const factory InputType.silentPaymentAddress(SilentPaymentAddressDetails field0) =
      InputType_SilentPaymentAddress;
  const factory InputType.lnurlAuth(LnurlAuthRequestDetails field0) = InputType_LnurlAuth;
  const factory InputType.url(String field0) = InputType_Url;
  const factory InputType.bip21(Bip21Details field0) = InputType_Bip21;
  const factory InputType.bolt12InvoiceRequest(Bolt12InvoiceRequestDetails field0) =
      InputType_Bolt12InvoiceRequest;
  const factory InputType.lnurlWithdraw(LnurlWithdrawRequestDetails field0) = InputType_LnurlWithdraw;
  const factory InputType.sparkAddress(SparkAddressDetails field0) = InputType_SparkAddress;
  const factory InputType.sparkInvoice(SparkInvoiceDetails field0) = InputType_SparkInvoice;
}

class KeySetConfig {
  final KeySetType keySetType;
  final bool useAddressIndex;
  final int? accountNumber;

  const KeySetConfig({required this.keySetType, required this.useAddressIndex, this.accountNumber});

  @override
  int get hashCode => keySetType.hashCode ^ useAddressIndex.hashCode ^ accountNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeySetConfig &&
          runtimeType == other.runtimeType &&
          keySetType == other.keySetType &&
          useAddressIndex == other.useAddressIndex &&
          accountNumber == other.accountNumber;
}

enum KeySetType { default_, taproot, nativeSegwit, wrappedSegwit, legacy }

class LightningAddressDetails {
  final String address;
  final LnurlPayRequestDetails payRequest;

  const LightningAddressDetails({required this.address, required this.payRequest});

  @override
  int get hashCode => address.hashCode ^ payRequest.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LightningAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          payRequest == other.payRequest;
}

class LightningAddressInfo {
  final String description;
  final String lightningAddress;
  final String lnurl;
  final String username;

  const LightningAddressInfo({
    required this.description,
    required this.lightningAddress,
    required this.lnurl,
    required this.username,
  });

  @override
  int get hashCode => description.hashCode ^ lightningAddress.hashCode ^ lnurl.hashCode ^ username.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LightningAddressInfo &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          lightningAddress == other.lightningAddress &&
          lnurl == other.lnurl &&
          username == other.username;
}

class ListFiatCurrenciesResponse {
  final List<FiatCurrency> currencies;

  const ListFiatCurrenciesResponse({required this.currencies});

  @override
  int get hashCode => currencies.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListFiatCurrenciesResponse &&
          runtimeType == other.runtimeType &&
          currencies == other.currencies;
}

class ListFiatRatesResponse {
  final List<Rate> rates;

  const ListFiatRatesResponse({required this.rates});

  @override
  int get hashCode => rates.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListFiatRatesResponse && runtimeType == other.runtimeType && rates == other.rates;
}

class ListPaymentsRequest {
  final List<PaymentType>? typeFilter;
  final List<PaymentStatus>? statusFilter;
  final AssetFilter? assetFilter;
  final List<PaymentDetailsFilter>? paymentDetailsFilter;
  final BigInt? fromTimestamp;
  final BigInt? toTimestamp;
  final int? offset;
  final int? limit;
  final bool? sortAscending;

  const ListPaymentsRequest({
    this.typeFilter,
    this.statusFilter,
    this.assetFilter,
    this.paymentDetailsFilter,
    this.fromTimestamp,
    this.toTimestamp,
    this.offset,
    this.limit,
    this.sortAscending,
  });

  @override
  int get hashCode =>
      typeFilter.hashCode ^
      statusFilter.hashCode ^
      assetFilter.hashCode ^
      paymentDetailsFilter.hashCode ^
      fromTimestamp.hashCode ^
      toTimestamp.hashCode ^
      offset.hashCode ^
      limit.hashCode ^
      sortAscending.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsRequest &&
          runtimeType == other.runtimeType &&
          typeFilter == other.typeFilter &&
          statusFilter == other.statusFilter &&
          assetFilter == other.assetFilter &&
          paymentDetailsFilter == other.paymentDetailsFilter &&
          fromTimestamp == other.fromTimestamp &&
          toTimestamp == other.toTimestamp &&
          offset == other.offset &&
          limit == other.limit &&
          sortAscending == other.sortAscending;
}

class ListPaymentsResponse {
  final List<Payment> payments;

  const ListPaymentsResponse({required this.payments});

  @override
  int get hashCode => payments.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsResponse && runtimeType == other.runtimeType && payments == other.payments;
}

class ListUnclaimedDepositsRequest {
  const ListUnclaimedDepositsRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is ListUnclaimedDepositsRequest && runtimeType == other.runtimeType;
}

class ListUnclaimedDepositsResponse {
  final List<DepositInfo> deposits;

  const ListUnclaimedDepositsResponse({required this.deposits});

  @override
  int get hashCode => deposits.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListUnclaimedDepositsResponse &&
          runtimeType == other.runtimeType &&
          deposits == other.deposits;
}

class LnurlAuthRequestDetails {
  final String k1;
  final String? action;
  final String domain;
  final String url;

  const LnurlAuthRequestDetails({required this.k1, this.action, required this.domain, required this.url});

  @override
  int get hashCode => k1.hashCode ^ action.hashCode ^ domain.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlAuthRequestDetails &&
          runtimeType == other.runtimeType &&
          k1 == other.k1 &&
          action == other.action &&
          domain == other.domain &&
          url == other.url;
}

@freezed
sealed class LnurlCallbackStatus with _$LnurlCallbackStatus {
  const LnurlCallbackStatus._();

  const factory LnurlCallbackStatus.ok() = LnurlCallbackStatus_Ok;
  const factory LnurlCallbackStatus.errorStatus({required LnurlErrorDetails errorDetails}) =
      LnurlCallbackStatus_ErrorStatus;
}

class LnurlErrorDetails {
  final String reason;

  const LnurlErrorDetails({required this.reason});

  @override
  int get hashCode => reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlErrorDetails && runtimeType == other.runtimeType && reason == other.reason;
}

class LnurlPayInfo {
  final String? lnAddress;
  final String? comment;
  final String? domain;
  final String? metadata;
  final SuccessActionProcessed? processedSuccessAction;
  final SuccessAction? rawSuccessAction;

  const LnurlPayInfo({
    this.lnAddress,
    this.comment,
    this.domain,
    this.metadata,
    this.processedSuccessAction,
    this.rawSuccessAction,
  });

  @override
  int get hashCode =>
      lnAddress.hashCode ^
      comment.hashCode ^
      domain.hashCode ^
      metadata.hashCode ^
      processedSuccessAction.hashCode ^
      rawSuccessAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayInfo &&
          runtimeType == other.runtimeType &&
          lnAddress == other.lnAddress &&
          comment == other.comment &&
          domain == other.domain &&
          metadata == other.metadata &&
          processedSuccessAction == other.processedSuccessAction &&
          rawSuccessAction == other.rawSuccessAction;
}

class LnurlPayRequest {
  final PrepareLnurlPayResponse prepareResponse;
  final String? idempotencyKey;

  const LnurlPayRequest({required this.prepareResponse, this.idempotencyKey});

  @override
  int get hashCode => prepareResponse.hashCode ^ idempotencyKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          idempotencyKey == other.idempotencyKey;
}

class LnurlPayRequestDetails {
  final String callback;
  final BigInt minSendable;
  final BigInt maxSendable;
  final String metadataStr;
  final int commentAllowed;
  final String domain;
  final String url;
  final String? address;
  final bool? allowsNostr;
  final String? nostrPubkey;

  const LnurlPayRequestDetails({
    required this.callback,
    required this.minSendable,
    required this.maxSendable,
    required this.metadataStr,
    required this.commentAllowed,
    required this.domain,
    required this.url,
    this.address,
    this.allowsNostr,
    this.nostrPubkey,
  });

  @override
  int get hashCode =>
      callback.hashCode ^
      minSendable.hashCode ^
      maxSendable.hashCode ^
      metadataStr.hashCode ^
      commentAllowed.hashCode ^
      domain.hashCode ^
      url.hashCode ^
      address.hashCode ^
      allowsNostr.hashCode ^
      nostrPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayRequestDetails &&
          runtimeType == other.runtimeType &&
          callback == other.callback &&
          minSendable == other.minSendable &&
          maxSendable == other.maxSendable &&
          metadataStr == other.metadataStr &&
          commentAllowed == other.commentAllowed &&
          domain == other.domain &&
          url == other.url &&
          address == other.address &&
          allowsNostr == other.allowsNostr &&
          nostrPubkey == other.nostrPubkey;
}

class LnurlPayResponse {
  final Payment payment;
  final SuccessActionProcessed? successAction;

  const LnurlPayResponse({required this.payment, this.successAction});

  @override
  int get hashCode => payment.hashCode ^ successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayResponse &&
          runtimeType == other.runtimeType &&
          payment == other.payment &&
          successAction == other.successAction;
}

class LnurlReceiveMetadata {
  final String? nostrZapRequest;
  final String? nostrZapReceipt;
  final String? senderComment;

  const LnurlReceiveMetadata({this.nostrZapRequest, this.nostrZapReceipt, this.senderComment});

  @override
  int get hashCode => nostrZapRequest.hashCode ^ nostrZapReceipt.hashCode ^ senderComment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlReceiveMetadata &&
          runtimeType == other.runtimeType &&
          nostrZapRequest == other.nostrZapRequest &&
          nostrZapReceipt == other.nostrZapReceipt &&
          senderComment == other.senderComment;
}

class LnurlWithdrawInfo {
  final String withdrawUrl;

  const LnurlWithdrawInfo({required this.withdrawUrl});

  @override
  int get hashCode => withdrawUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlWithdrawInfo && runtimeType == other.runtimeType && withdrawUrl == other.withdrawUrl;
}

class LnurlWithdrawRequest {
  final BigInt amountSats;
  final LnurlWithdrawRequestDetails withdrawRequest;
  final int? completionTimeoutSecs;

  const LnurlWithdrawRequest({
    required this.amountSats,
    required this.withdrawRequest,
    this.completionTimeoutSecs,
  });

  @override
  int get hashCode => amountSats.hashCode ^ withdrawRequest.hashCode ^ completionTimeoutSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlWithdrawRequest &&
          runtimeType == other.runtimeType &&
          amountSats == other.amountSats &&
          withdrawRequest == other.withdrawRequest &&
          completionTimeoutSecs == other.completionTimeoutSecs;
}

class LnurlWithdrawRequestDetails {
  final String callback;
  final String k1;
  final String defaultDescription;
  final BigInt minWithdrawable;
  final BigInt maxWithdrawable;

  const LnurlWithdrawRequestDetails({
    required this.callback,
    required this.k1,
    required this.defaultDescription,
    required this.minWithdrawable,
    required this.maxWithdrawable,
  });

  @override
  int get hashCode =>
      callback.hashCode ^
      k1.hashCode ^
      defaultDescription.hashCode ^
      minWithdrawable.hashCode ^
      maxWithdrawable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlWithdrawRequestDetails &&
          runtimeType == other.runtimeType &&
          callback == other.callback &&
          k1 == other.k1 &&
          defaultDescription == other.defaultDescription &&
          minWithdrawable == other.minWithdrawable &&
          maxWithdrawable == other.maxWithdrawable;
}

class LnurlWithdrawResponse {
  final String paymentRequest;
  final Payment? payment;

  const LnurlWithdrawResponse({required this.paymentRequest, this.payment});

  @override
  int get hashCode => paymentRequest.hashCode ^ payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlWithdrawResponse &&
          runtimeType == other.runtimeType &&
          paymentRequest == other.paymentRequest &&
          payment == other.payment;
}

class LocaleOverrides {
  final String locale;
  final int? spacing;
  final Symbol symbol;

  const LocaleOverrides({required this.locale, this.spacing, required this.symbol});

  @override
  int get hashCode => locale.hashCode ^ spacing.hashCode ^ symbol.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocaleOverrides &&
          runtimeType == other.runtimeType &&
          locale == other.locale &&
          spacing == other.spacing &&
          symbol == other.symbol;
}

class LocalizedName {
  final String locale;
  final String name;

  const LocalizedName({required this.locale, required this.name});

  @override
  int get hashCode => locale.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocalizedName &&
          runtimeType == other.runtimeType &&
          locale == other.locale &&
          name == other.name;
}

@freezed
sealed class MaxFee with _$MaxFee {
  const MaxFee._();

  const factory MaxFee.fixed({required BigInt amount}) = MaxFee_Fixed;
  const factory MaxFee.rate({required BigInt satPerVbyte}) = MaxFee_Rate;
  const factory MaxFee.networkRecommended({required BigInt leewaySatPerVbyte}) = MaxFee_NetworkRecommended;
}

class MessageSuccessActionData {
  final String message;

  const MessageSuccessActionData({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageSuccessActionData && runtimeType == other.runtimeType && message == other.message;
}

class MintIssuerTokenRequest {
  final BigInt amount;

  const MintIssuerTokenRequest({required this.amount});

  @override
  int get hashCode => amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MintIssuerTokenRequest && runtimeType == other.runtimeType && amount == other.amount;
}

enum Network { mainnet, regtest }

enum OnchainConfirmationSpeed { fast, medium, slow }

class OptimizationConfig {
  final bool autoEnabled;
  final int multiplicity;

  const OptimizationConfig({required this.autoEnabled, required this.multiplicity});

  @override
  int get hashCode => autoEnabled.hashCode ^ multiplicity.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OptimizationConfig &&
          runtimeType == other.runtimeType &&
          autoEnabled == other.autoEnabled &&
          multiplicity == other.multiplicity;
}

class OptimizationProgress {
  final bool isRunning;
  final int currentRound;
  final int totalRounds;

  const OptimizationProgress({
    required this.isRunning,
    required this.currentRound,
    required this.totalRounds,
  });

  @override
  int get hashCode => isRunning.hashCode ^ currentRound.hashCode ^ totalRounds.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OptimizationProgress &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          currentRound == other.currentRound &&
          totalRounds == other.totalRounds;
}

class Payment {
  final String id;
  final PaymentType paymentType;
  final PaymentStatus status;
  final BigInt amount;
  final BigInt fees;
  final BigInt timestamp;
  final PaymentMethod method;
  final PaymentDetails? details;

  const Payment({
    required this.id,
    required this.paymentType,
    required this.status,
    required this.amount,
    required this.fees,
    required this.timestamp,
    required this.method,
    this.details,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      paymentType.hashCode ^
      status.hashCode ^
      amount.hashCode ^
      fees.hashCode ^
      timestamp.hashCode ^
      method.hashCode ^
      details.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Payment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          paymentType == other.paymentType &&
          status == other.status &&
          amount == other.amount &&
          fees == other.fees &&
          timestamp == other.timestamp &&
          method == other.method &&
          details == other.details;
}

@freezed
sealed class PaymentDetails with _$PaymentDetails {
  const PaymentDetails._();

  const factory PaymentDetails.spark({
    SparkInvoicePaymentDetails? invoiceDetails,
    SparkHtlcDetails? htlcDetails,
    ConversionInfo? conversionInfo,
  }) = PaymentDetails_Spark;
  const factory PaymentDetails.token({
    required TokenMetadata metadata,
    required String txHash,
    SparkInvoicePaymentDetails? invoiceDetails,
    ConversionInfo? conversionInfo,
  }) = PaymentDetails_Token;
  const factory PaymentDetails.lightning({
    String? description,
    String? preimage,
    required String invoice,
    required String paymentHash,
    required String destinationPubkey,
    LnurlPayInfo? lnurlPayInfo,
    LnurlWithdrawInfo? lnurlWithdrawInfo,
    LnurlReceiveMetadata? lnurlReceiveMetadata,
  }) = PaymentDetails_Lightning;
  const factory PaymentDetails.withdraw({required String txId}) = PaymentDetails_Withdraw;
  const factory PaymentDetails.deposit({required String txId}) = PaymentDetails_Deposit;
}

@freezed
sealed class PaymentDetailsFilter with _$PaymentDetailsFilter {
  const PaymentDetailsFilter._();

  const factory PaymentDetailsFilter.spark({
    List<SparkHtlcStatus>? htlcStatus,
    bool? conversionRefundNeeded,
  }) = PaymentDetailsFilter_Spark;
  const factory PaymentDetailsFilter.token({bool? conversionRefundNeeded, String? txHash}) =
      PaymentDetailsFilter_Token;
}

enum PaymentMethod { lightning, spark, token, deposit, withdraw, unknown }

class PaymentRequestSource {
  final String? bip21Uri;
  final String? bip353Address;

  const PaymentRequestSource({this.bip21Uri, this.bip353Address});

  @override
  int get hashCode => bip21Uri.hashCode ^ bip353Address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentRequestSource &&
          runtimeType == other.runtimeType &&
          bip21Uri == other.bip21Uri &&
          bip353Address == other.bip353Address;
}

enum PaymentStatus { completed, pending, failed }

enum PaymentType { send, receive }

class PrepareLnurlPayRequest {
  final BigInt amountSats;
  final LnurlPayRequestDetails payRequest;
  final String? comment;
  final bool? validateSuccessActionUrl;

  const PrepareLnurlPayRequest({
    required this.amountSats,
    required this.payRequest,
    this.comment,
    this.validateSuccessActionUrl,
  });

  @override
  int get hashCode =>
      amountSats.hashCode ^ payRequest.hashCode ^ comment.hashCode ^ validateSuccessActionUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnurlPayRequest &&
          runtimeType == other.runtimeType &&
          amountSats == other.amountSats &&
          payRequest == other.payRequest &&
          comment == other.comment &&
          validateSuccessActionUrl == other.validateSuccessActionUrl;
}

class PrepareLnurlPayResponse {
  final BigInt amountSats;
  final String? comment;
  final LnurlPayRequestDetails payRequest;
  final BigInt feeSats;
  final Bolt11InvoiceDetails invoiceDetails;
  final SuccessAction? successAction;

  const PrepareLnurlPayResponse({
    required this.amountSats,
    this.comment,
    required this.payRequest,
    required this.feeSats,
    required this.invoiceDetails,
    this.successAction,
  });

  @override
  int get hashCode =>
      amountSats.hashCode ^
      comment.hashCode ^
      payRequest.hashCode ^
      feeSats.hashCode ^
      invoiceDetails.hashCode ^
      successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnurlPayResponse &&
          runtimeType == other.runtimeType &&
          amountSats == other.amountSats &&
          comment == other.comment &&
          payRequest == other.payRequest &&
          feeSats == other.feeSats &&
          invoiceDetails == other.invoiceDetails &&
          successAction == other.successAction;
}

class PrepareSendPaymentRequest {
  final String paymentRequest;
  final BigInt? amount;
  final String? tokenIdentifier;
  final ConversionOptions? conversionOptions;

  const PrepareSendPaymentRequest({
    required this.paymentRequest,
    this.amount,
    this.tokenIdentifier,
    this.conversionOptions,
  });

  @override
  int get hashCode =>
      paymentRequest.hashCode ^ amount.hashCode ^ tokenIdentifier.hashCode ^ conversionOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareSendPaymentRequest &&
          runtimeType == other.runtimeType &&
          paymentRequest == other.paymentRequest &&
          amount == other.amount &&
          tokenIdentifier == other.tokenIdentifier &&
          conversionOptions == other.conversionOptions;
}

class PrepareSendPaymentResponse {
  final SendPaymentMethod paymentMethod;
  final BigInt amount;
  final String? tokenIdentifier;
  final ConversionEstimate? conversionEstimate;

  const PrepareSendPaymentResponse({
    required this.paymentMethod,
    required this.amount,
    this.tokenIdentifier,
    this.conversionEstimate,
  });

  @override
  int get hashCode =>
      paymentMethod.hashCode ^ amount.hashCode ^ tokenIdentifier.hashCode ^ conversionEstimate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareSendPaymentResponse &&
          runtimeType == other.runtimeType &&
          paymentMethod == other.paymentMethod &&
          amount == other.amount &&
          tokenIdentifier == other.tokenIdentifier &&
          conversionEstimate == other.conversionEstimate;
}

class Rate {
  final String coin;
  final double value;

  const Rate({required this.coin, required this.value});

  @override
  int get hashCode => coin.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Rate && runtimeType == other.runtimeType && coin == other.coin && value == other.value;
}

@freezed
sealed class ReceivePaymentMethod with _$ReceivePaymentMethod {
  const ReceivePaymentMethod._();

  const factory ReceivePaymentMethod.sparkAddress() = ReceivePaymentMethod_SparkAddress;
  const factory ReceivePaymentMethod.sparkInvoice({
    BigInt? amount,
    String? tokenIdentifier,
    BigInt? expiryTime,
    String? description,
    String? senderPublicKey,
  }) = ReceivePaymentMethod_SparkInvoice;
  const factory ReceivePaymentMethod.bitcoinAddress() = ReceivePaymentMethod_BitcoinAddress;
  const factory ReceivePaymentMethod.bolt11Invoice({
    required String description,
    BigInt? amountSats,
    int? expirySecs,
  }) = ReceivePaymentMethod_Bolt11Invoice;
}

class ReceivePaymentRequest {
  final ReceivePaymentMethod paymentMethod;

  const ReceivePaymentRequest({required this.paymentMethod});

  @override
  int get hashCode => paymentMethod.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentRequest &&
          runtimeType == other.runtimeType &&
          paymentMethod == other.paymentMethod;
}

class ReceivePaymentResponse {
  final String paymentRequest;
  final BigInt fee;

  const ReceivePaymentResponse({required this.paymentRequest, required this.fee});

  @override
  int get hashCode => paymentRequest.hashCode ^ fee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentResponse &&
          runtimeType == other.runtimeType &&
          paymentRequest == other.paymentRequest &&
          fee == other.fee;
}

class RecommendedFees {
  final BigInt fastestFee;
  final BigInt halfHourFee;
  final BigInt hourFee;
  final BigInt economyFee;
  final BigInt minimumFee;

  const RecommendedFees({
    required this.fastestFee,
    required this.halfHourFee,
    required this.hourFee,
    required this.economyFee,
    required this.minimumFee,
  });

  @override
  int get hashCode =>
      fastestFee.hashCode ^
      halfHourFee.hashCode ^
      hourFee.hashCode ^
      economyFee.hashCode ^
      minimumFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RecommendedFees &&
          runtimeType == other.runtimeType &&
          fastestFee == other.fastestFee &&
          halfHourFee == other.halfHourFee &&
          hourFee == other.hourFee &&
          economyFee == other.economyFee &&
          minimumFee == other.minimumFee;
}

class RefundDepositRequest {
  final String txid;
  final int vout;
  final String destinationAddress;
  final Fee fee;

  const RefundDepositRequest({
    required this.txid,
    required this.vout,
    required this.destinationAddress,
    required this.fee,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode ^ destinationAddress.hashCode ^ fee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundDepositRequest &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          destinationAddress == other.destinationAddress &&
          fee == other.fee;
}

class RefundDepositResponse {
  final String txId;
  final String txHex;

  const RefundDepositResponse({required this.txId, required this.txHex});

  @override
  int get hashCode => txId.hashCode ^ txHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundDepositResponse &&
          runtimeType == other.runtimeType &&
          txId == other.txId &&
          txHex == other.txHex;
}

class RegisterLightningAddressRequest {
  final String username;
  final String? description;

  const RegisterLightningAddressRequest({required this.username, this.description});

  @override
  int get hashCode => username.hashCode ^ description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RegisterLightningAddressRequest &&
          runtimeType == other.runtimeType &&
          username == other.username &&
          description == other.description;
}

@freezed
sealed class Seed with _$Seed {
  const Seed._();

  const factory Seed.mnemonic({required String mnemonic, String? passphrase}) = Seed_Mnemonic;
  const factory Seed.entropy(Uint8List field0) = Seed_Entropy;
}

class SendOnchainFeeQuote {
  final String id;
  final BigInt expiresAt;
  final SendOnchainSpeedFeeQuote speedFast;
  final SendOnchainSpeedFeeQuote speedMedium;
  final SendOnchainSpeedFeeQuote speedSlow;

  const SendOnchainFeeQuote({
    required this.id,
    required this.expiresAt,
    required this.speedFast,
    required this.speedMedium,
    required this.speedSlow,
  });

  @override
  int get hashCode =>
      id.hashCode ^ expiresAt.hashCode ^ speedFast.hashCode ^ speedMedium.hashCode ^ speedSlow.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendOnchainFeeQuote &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          expiresAt == other.expiresAt &&
          speedFast == other.speedFast &&
          speedMedium == other.speedMedium &&
          speedSlow == other.speedSlow;
}

class SendOnchainSpeedFeeQuote {
  final BigInt userFeeSat;
  final BigInt l1BroadcastFeeSat;

  const SendOnchainSpeedFeeQuote({required this.userFeeSat, required this.l1BroadcastFeeSat});

  @override
  int get hashCode => userFeeSat.hashCode ^ l1BroadcastFeeSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendOnchainSpeedFeeQuote &&
          runtimeType == other.runtimeType &&
          userFeeSat == other.userFeeSat &&
          l1BroadcastFeeSat == other.l1BroadcastFeeSat;
}

@freezed
sealed class SendPaymentMethod with _$SendPaymentMethod {
  const SendPaymentMethod._();

  const factory SendPaymentMethod.bitcoinAddress({
    required BitcoinAddressDetails address,
    required SendOnchainFeeQuote feeQuote,
  }) = SendPaymentMethod_BitcoinAddress;
  const factory SendPaymentMethod.bolt11Invoice({
    required Bolt11InvoiceDetails invoiceDetails,
    BigInt? sparkTransferFeeSats,
    required BigInt lightningFeeSats,
  }) = SendPaymentMethod_Bolt11Invoice;
  const factory SendPaymentMethod.sparkAddress({
    required String address,
    required BigInt fee,
    String? tokenIdentifier,
  }) = SendPaymentMethod_SparkAddress;
  const factory SendPaymentMethod.sparkInvoice({
    required SparkInvoiceDetails sparkInvoiceDetails,
    required BigInt fee,
    String? tokenIdentifier,
  }) = SendPaymentMethod_SparkInvoice;
}

@freezed
sealed class SendPaymentOptions with _$SendPaymentOptions {
  const SendPaymentOptions._();

  const factory SendPaymentOptions.bitcoinAddress({required OnchainConfirmationSpeed confirmationSpeed}) =
      SendPaymentOptions_BitcoinAddress;
  const factory SendPaymentOptions.bolt11Invoice({required bool preferSpark, int? completionTimeoutSecs}) =
      SendPaymentOptions_Bolt11Invoice;
  const factory SendPaymentOptions.sparkAddress({SparkHtlcOptions? htlcOptions}) =
      SendPaymentOptions_SparkAddress;
}

class SendPaymentRequest {
  final PrepareSendPaymentResponse prepareResponse;
  final SendPaymentOptions? options;
  final String? idempotencyKey;

  const SendPaymentRequest({required this.prepareResponse, this.options, this.idempotencyKey});

  @override
  int get hashCode => prepareResponse.hashCode ^ options.hashCode ^ idempotencyKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          options == other.options &&
          idempotencyKey == other.idempotencyKey;
}

class SendPaymentResponse {
  final Payment payment;

  const SendPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

class SignMessageRequest {
  final String message;
  final bool compact;

  const SignMessageRequest({required this.message, required this.compact});

  @override
  int get hashCode => message.hashCode ^ compact.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignMessageRequest &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          compact == other.compact;
}

class SignMessageResponse {
  final String pubkey;
  final String signature;

  const SignMessageResponse({required this.pubkey, required this.signature});

  @override
  int get hashCode => pubkey.hashCode ^ signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignMessageResponse &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          signature == other.signature;
}

class SilentPaymentAddressDetails {
  final String address;
  final BitcoinNetwork network;
  final PaymentRequestSource source;

  const SilentPaymentAddressDetails({required this.address, required this.network, required this.source});

  @override
  int get hashCode => address.hashCode ^ network.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SilentPaymentAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          network == other.network &&
          source == other.source;
}

class SparkAddressDetails {
  final String address;
  final String identityPublicKey;
  final BitcoinNetwork network;
  final PaymentRequestSource source;

  const SparkAddressDetails({
    required this.address,
    required this.identityPublicKey,
    required this.network,
    required this.source,
  });

  @override
  int get hashCode => address.hashCode ^ identityPublicKey.hashCode ^ network.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkAddressDetails &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          identityPublicKey == other.identityPublicKey &&
          network == other.network &&
          source == other.source;
}

class SparkHtlcDetails {
  final String paymentHash;
  final String? preimage;
  final BigInt expiryTime;
  final SparkHtlcStatus status;

  const SparkHtlcDetails({
    required this.paymentHash,
    this.preimage,
    required this.expiryTime,
    required this.status,
  });

  @override
  int get hashCode => paymentHash.hashCode ^ preimage.hashCode ^ expiryTime.hashCode ^ status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkHtlcDetails &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          preimage == other.preimage &&
          expiryTime == other.expiryTime &&
          status == other.status;
}

class SparkHtlcOptions {
  final String paymentHash;
  final BigInt expiryDurationSecs;

  const SparkHtlcOptions({required this.paymentHash, required this.expiryDurationSecs});

  @override
  int get hashCode => paymentHash.hashCode ^ expiryDurationSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkHtlcOptions &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          expiryDurationSecs == other.expiryDurationSecs;
}

enum SparkHtlcStatus { waitingForPreimage, preimageShared, returned }

class SparkInvoiceDetails {
  final String invoice;
  final String identityPublicKey;
  final BitcoinNetwork network;
  final BigInt? amount;
  final String? tokenIdentifier;
  final BigInt? expiryTime;
  final String? description;
  final String? senderPublicKey;

  const SparkInvoiceDetails({
    required this.invoice,
    required this.identityPublicKey,
    required this.network,
    this.amount,
    this.tokenIdentifier,
    this.expiryTime,
    this.description,
    this.senderPublicKey,
  });

  @override
  int get hashCode =>
      invoice.hashCode ^
      identityPublicKey.hashCode ^
      network.hashCode ^
      amount.hashCode ^
      tokenIdentifier.hashCode ^
      expiryTime.hashCode ^
      description.hashCode ^
      senderPublicKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkInvoiceDetails &&
          runtimeType == other.runtimeType &&
          invoice == other.invoice &&
          identityPublicKey == other.identityPublicKey &&
          network == other.network &&
          amount == other.amount &&
          tokenIdentifier == other.tokenIdentifier &&
          expiryTime == other.expiryTime &&
          description == other.description &&
          senderPublicKey == other.senderPublicKey;
}

class SparkInvoicePaymentDetails {
  final String? description;
  final String invoice;

  const SparkInvoicePaymentDetails({this.description, required this.invoice});

  @override
  int get hashCode => description.hashCode ^ invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SparkInvoicePaymentDetails &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          invoice == other.invoice;
}

@freezed
sealed class SuccessAction with _$SuccessAction {
  const SuccessAction._();

  const factory SuccessAction.aes({required AesSuccessActionData data}) = SuccessAction_Aes;
  const factory SuccessAction.message({required MessageSuccessActionData data}) = SuccessAction_Message;
  const factory SuccessAction.url({required UrlSuccessActionData data}) = SuccessAction_Url;
}

@freezed
sealed class SuccessActionProcessed with _$SuccessActionProcessed {
  const SuccessActionProcessed._();

  const factory SuccessActionProcessed.aes({required AesSuccessActionDataResult result}) =
      SuccessActionProcessed_Aes;
  const factory SuccessActionProcessed.message({required MessageSuccessActionData data}) =
      SuccessActionProcessed_Message;
  const factory SuccessActionProcessed.url({required UrlSuccessActionData data}) = SuccessActionProcessed_Url;
}

class Symbol {
  final String? grapheme;
  final String? template;
  final bool? rtl;
  final int? position;

  const Symbol({this.grapheme, this.template, this.rtl, this.position});

  @override
  int get hashCode => grapheme.hashCode ^ template.hashCode ^ rtl.hashCode ^ position.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Symbol &&
          runtimeType == other.runtimeType &&
          grapheme == other.grapheme &&
          template == other.template &&
          rtl == other.rtl &&
          position == other.position;
}

class SyncWalletRequest {
  const SyncWalletRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is SyncWalletRequest && runtimeType == other.runtimeType;
}

class SyncWalletResponse {
  const SyncWalletResponse();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is SyncWalletResponse && runtimeType == other.runtimeType;
}

class TokenBalance {
  final BigInt balance;
  final TokenMetadata tokenMetadata;

  const TokenBalance({required this.balance, required this.tokenMetadata});

  @override
  int get hashCode => balance.hashCode ^ tokenMetadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenBalance &&
          runtimeType == other.runtimeType &&
          balance == other.balance &&
          tokenMetadata == other.tokenMetadata;
}

class TokenMetadata {
  final String identifier;
  final String issuerPublicKey;
  final String name;
  final String ticker;
  final int decimals;
  final BigInt maxSupply;
  final bool isFreezable;

  const TokenMetadata({
    required this.identifier,
    required this.issuerPublicKey,
    required this.name,
    required this.ticker,
    required this.decimals,
    required this.maxSupply,
    required this.isFreezable,
  });

  @override
  int get hashCode =>
      identifier.hashCode ^
      issuerPublicKey.hashCode ^
      name.hashCode ^
      ticker.hashCode ^
      decimals.hashCode ^
      maxSupply.hashCode ^
      isFreezable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenMetadata &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          issuerPublicKey == other.issuerPublicKey &&
          name == other.name &&
          ticker == other.ticker &&
          decimals == other.decimals &&
          maxSupply == other.maxSupply &&
          isFreezable == other.isFreezable;
}

class UnfreezeIssuerTokenRequest {
  final String address;

  const UnfreezeIssuerTokenRequest({required this.address});

  @override
  int get hashCode => address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnfreezeIssuerTokenRequest && runtimeType == other.runtimeType && address == other.address;
}

class UnfreezeIssuerTokenResponse {
  final List<String> impactedOutputIds;
  final BigInt impactedTokenAmount;

  const UnfreezeIssuerTokenResponse({required this.impactedOutputIds, required this.impactedTokenAmount});

  @override
  int get hashCode => impactedOutputIds.hashCode ^ impactedTokenAmount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnfreezeIssuerTokenResponse &&
          runtimeType == other.runtimeType &&
          impactedOutputIds == other.impactedOutputIds &&
          impactedTokenAmount == other.impactedTokenAmount;
}

class UpdateUserSettingsRequest {
  final bool? sparkPrivateModeEnabled;

  const UpdateUserSettingsRequest({this.sparkPrivateModeEnabled});

  @override
  int get hashCode => sparkPrivateModeEnabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateUserSettingsRequest &&
          runtimeType == other.runtimeType &&
          sparkPrivateModeEnabled == other.sparkPrivateModeEnabled;
}

class UrlSuccessActionData {
  final String description;
  final String url;
  final bool matchesCallbackDomain;

  const UrlSuccessActionData({
    required this.description,
    required this.url,
    required this.matchesCallbackDomain,
  });

  @override
  int get hashCode => description.hashCode ^ url.hashCode ^ matchesCallbackDomain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UrlSuccessActionData &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          url == other.url &&
          matchesCallbackDomain == other.matchesCallbackDomain;
}

class UserSettings {
  final bool sparkPrivateModeEnabled;

  const UserSettings({required this.sparkPrivateModeEnabled});

  @override
  int get hashCode => sparkPrivateModeEnabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserSettings &&
          runtimeType == other.runtimeType &&
          sparkPrivateModeEnabled == other.sparkPrivateModeEnabled;
}
